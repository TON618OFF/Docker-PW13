# Техническая документация проекта ImperialTunes

## Общая архитектура

Проект состоит из двух частей:
- **Frontend**: React приложение (SPA) на TypeScript
- **Backend**: Supabase (PostgreSQL + Authentication + Storage)

Приложение работает как клиент-серверная система: React запрашивает данные через Supabase API, база данных обрабатывает запросы с учётом RLS политик, файлы хранятся в Supabase Storage.

---

## Frontend (React + TypeScript)

### Сборка и запуск

**Vite** — сборщик и dev-сервер:
- `npm run dev` — запуск dev-сервера на порту 8080
- `npm run build` — сборка production версии
- Hot Module Replacement (HMR) для быстрой разработки

**Пути и алиасы:**
- `@/` → `src/` (настроено в `vite.config.ts`)
- Используется для импортов: `import { supabase } from "@/integrations/supabase/client"`

### Структура компонентов

**App.tsx** — корневой компонент:
```typescript
QueryClientProvider → AppSettingsProvider → PlayerProvider → BrowserRouter
```

**Маршрутизация (React Router):**
- `/auth` — авторизация (без Layout)
- `/` — главная (с Layout)
- `/library` — библиотека треков
- `/playlists` — плейлисты
- `/profile` — профиль пользователя
- `/admin` — админ-панель (защищённый маршрут)
- `/applications` — заявки на артиста (защищённый маршрут)

**Layout.tsx** — общий макет:
- Header с навигацией
- Main content (Outlet для страниц)
- MusicPlayer (фиксированный внизу)
- Mobile navigation (нижняя панель на мобильных)

### Управление состоянием

**React Context API:**

1. **PlayerContext** (`src/contexts/PlayerContext.tsx`):
   - Хранит текущий трек, плейлист, режим перемешивания
   - Методы: `playTrack()`, `nextTrack()`, `previousTrack()`
   - Доступ через `usePlayer()`

2. **AppSettingsContext** (`src/contexts/AppSettingsContext.tsx`):
   - Хранит тему (dark/light) и язык (ru/en)
   - Сохраняет язык в БД, тему в localStorage
   - Применяет тему через классы `dark`/`light` на `document.documentElement`

**React Query** (`@tanstack/react-query`):
- Кэширует запросы к Supabase API
- Автоматически управляет состоянием загрузки и ошибок
- Инвалидация кэша при мутациях

### Стилизация

**Tailwind CSS** — utility-first CSS фреймворк:
- Классы вроде `flex`, `bg-primary`, `text-muted-foreground`
- Кастомные цвета в `tailwind.config.js` (primary, secondary)
- Темная/светлая тема через класс `dark` на корневом элементе

**Shadcn UI** — компоненты на базе Radix UI:
- Готовые компоненты: Button, Card, Dialog, Toast и т.д.
- Настраиваются через Tailwind
- Доступность из коробки

### Кастомные хуки

**useRole** (`src/hooks/useRole.ts`):
- Получает роль пользователя из БД
- Возвращает: `isAdmin`, `isDistributor`, `isArtist`, `canManageContent`
- Слушает изменения аутентификации через `onAuthStateChange`

**useTranslation** (`src/hooks/useTranslation.ts`):
- Интернационализация (i18n)
- Переводы в `src/lib/translations.ts`
- Переключение языка через `AppSettingsContext`

---

## Интеграция с Supabase

### Инициализация клиента

**`src/integrations/supabase/client.ts`:**
```typescript
const supabase = createClient(SUPABASE_URL, SUPABASE_KEY, {
  auth: {
    storage: localStorage,      // Хранение токена
    persistSession: true,        // Сохранение сессии
    autoRefreshToken: true       // Автообновление токена
  }
});
```

**Переменные окружения** (`.env`):
- `VITE_SUPABASE_URL` — URL проекта Supabase
- `VITE_SUPABASE_PUBLISHABLE_KEY` — публичный ключ (ANON_KEY)

### Типизация

**Типы базы данных:**
- Типы генерируются из схемы Supabase в `src/integrations/supabase/types.ts`
- Автоматическая типизация запросов через `createClient<Database>()`
- Типы для каждой таблицы: `Row`, `Insert`, `Update`

**Использование:**
```typescript
import type { Database } from "@/integrations/supabase/types";
type Track = Database["public"]["Tables"]["tracks"]["Row"];
```

### Работа с базой данных

**Запросы через Supabase Client:**

```typescript
// Получение данных
const { data, error } = await supabase
  .from("tracks")
  .select(`
    *,
    album:albums(*, artist:artists(*)),
    genres:track_genres(genre:genres(*))
  `)
  .eq("is_public", true)
  .order("created_at", { ascending: false });

// Вставка данных
const { data, error } = await supabase
  .from("tracks")
  .insert({ track_title: "Название", ... })
  .select()
  .single();

// Обновление данных
const { data, error } = await supabase
  .from("users")
  .update({ language: "en" })
  .eq("id", user.id);
```

**Особенности:**
- Автоматическое экранирование (защита от SQL-инъекций)
- RLS политики применяются автоматически
- Поддержка JOIN через синтаксис `table:related_table(*)`
- Типизация через `Database` тип из `types.ts`

### Работа с файлами (Storage)

**Загрузка файла:**
```typescript
const { data, error } = await supabase.storage
  .from("songs")  // bucket name
  .upload(`${userId}/${fileName}`, file);

// Получение публичного URL
const { data } = supabase.storage
  .from("songs")
  .getPublicUrl(`${userId}/${fileName}`);

// Получение подписанного URL (для приватных файлов)
const { data } = await supabase.storage
  .from("songs")
  .createSignedUrl(`${userId}/${fileName}`, 3600); // срок действия в секундах
```

**Buckets:**
- `songs` — аудиофайлы (приватный, требует подписанный URL)
- `covers` — обложки альбомов/артистов (публичный)
- `avatars` — аватары пользователей (публичный)

### Аутентификация

**Регистрация:**
```typescript
const { data, error } = await supabase.auth.signUp({
  email,
  password,
  options: {
    data: { username, first_name, last_name }
  }
});
```

**Вход:**
```typescript
const { data, error } = await supabase.auth.signInWithPassword({
  email,
  password
});
```

**Выход:**
```typescript
await supabase.auth.signOut();
```

**Получение текущего пользователя:**
```typescript
const { data: { user } } = await supabase.auth.getUser();
```

**Слушание изменений аутентификации:**
```typescript
supabase.auth.onAuthStateChange((event, session) => {
  if (event === 'SIGNED_IN') {
    // Пользователь вошёл
  } else if (event === 'SIGNED_OUT') {
    // Пользователь вышел
  }
});
```

**JWT токены:**
- Автоматически сохраняются в localStorage
- Автоматически добавляются в заголовки запросов
- Автоматически обновляются при истечении срока

---

## База данных (PostgreSQL)

### Структура

**Основные таблицы:**
- `roles` — роли пользователей
- `users` — профили пользователей (связь с `auth.users`)
- `artists` — артисты
- `albums` — альбомы
- `tracks` — треки
- `genres` — жанры
- `playlists` — плейлисты
- `track_genres` — связь трек-жанр (M:N)
- `playlist_tracks` — связь плейлист-трек (M:N)
- `listening_history` — история прослушиваний
- `favorites_*` — избранное (треки, альбомы, плейлисты)
- `artist_applications` — заявки на статус артиста
- `audit_log` — лог изменений

### Row Level Security (RLS)

**Принцип работы:**
- RLS политики проверяют права доступа на уровне базы данных
- Каждый запрос проверяется перед выполнением
- Пользователь видит только свои данные или публичные данные

**Пример политики:**
```sql
-- Пользователи могут видеть только публичные треки или свои треки
CREATE POLICY "Users can view public tracks or their own tracks"
ON tracks FOR SELECT
USING (is_public = true OR uploaded_by = auth.uid());
```

**Авторизация:**
- `auth.uid()` — ID текущего пользователя из JWT токена
- `auth.role()` — роль пользователя (если настроено)

### Функции и триггеры

**Функции:**
- `toggle_favorite_track()` — добавление/удаление трека из избранного
- `approve_artist_application()` — одобрение заявки на артиста
- `reject_artist_application()` — отклонение заявки

**Триггеры:**
- `handle_new_user()` — автоматическое создание профиля при регистрации
- `listening_history_trigger` — обновление счётчика прослушиваний
- `audit_changes()` — логирование изменений в `audit_log`
- `update_updated_at_column` — обновление поля `updated_at`

### Представления (Views)

**Представления для аналитики:**
- `album_duration` — длительность альбомов и количество треков
- `playlist_duration` — длительность плейлистов
- `user_statistics` — статистика пользователей
- `track_statistics` — статистика треков с уровнем популярности

---

## Основные функции

### Загрузка трека

**Процесс:**
1. Пользователь выбирает аудиофайл (валидация: формат, размер до 50 МБ)
2. Файл загружается в Storage bucket `songs`
3. Получается URL файла
4. Создаётся запись в таблице `tracks` с метаданными
5. Триггер `audit_changes()` логирует операцию

**Код** (`src/components/UploadTrackDialog.tsx`):
```typescript
// Загрузка файла
const { data: uploadData, error: uploadError } = await supabase.storage
  .from("songs")
  .upload(`${user.id}/${fileName}`, file);

// Получение URL
const { data: urlData } = supabase.storage
  .from("songs")
  .getPublicUrl(`${user.id}/${fileName}`);

// Создание записи в БД
const { data: trackData, error: trackError } = await supabase
  .from("tracks")
  .insert({
    track_title,
    track_duration,
    track_audio_url: urlData.publicUrl,
    album_id,
    uploaded_by: user.id
  })
  .select()
  .single();
```

### Воспроизведение трека

**Процесс:**
1. Пользователь выбирает трек
2. `PlayerContext` устанавливает текущий трек
3. `MusicPlayer` получает URL файла из Storage
4. Если файл приватный, получается подписанный URL
5. HTML5 Audio элемент воспроизводит файл
6. При завершении создаётся запись в `listening_history`
7. Триггер обновляет счётчик `track_play_count`

**Код** (`src/components/MusicPlayer.tsx`):
```typescript
// Получение подписанного URL для приватного файла
const getSignedUrl = async (filePath: string) => {
  const { data, error } = await supabase.storage
    .from("songs")
    .createSignedUrl(filePath, 3600); // срок действия 1 час
  return data?.signedUrl;
};

// Воспроизведение
const audio = new Audio(audioUrl);
audio.play();

// Запись истории прослушивания
await supabase.from("listening_history").insert({
  user_id: user.id,
  track_id: track.id,
  completed: true
});
```

### Создание плейлиста

**Процесс:**
1. Пользователь создаёт плейлист (название, описание)
2. Создаётся запись в таблице `playlists`
3. Пользователь добавляет треки в плейлист
4. Создаются связи в таблице `playlist_tracks` с порядком

**Код:**
```typescript
// Создание плейлиста
const { data: playlist, error } = await supabase
  .from("playlists")
  .insert({
    playlist_title,
    playlist_description,
    user_id: user.id,
    is_public: false
  })
  .select()
  .single();

// Добавление трека в плейлист
await supabase.from("playlist_tracks").insert({
  playlist_id: playlist.id,
  track_id: track.id,
  order_position: position
});
```

### Защита маршрутов

**ProtectedRoute** (`src/components/ProtectedRoute.tsx`):
- Проверяет авторизацию пользователя
- Проверяет роль пользователя (для админ-панели)
- Перенаправляет на `/auth` при отсутствии авторизации
- Перенаправляет на `/` при отсутствии прав

**Использование:**
```typescript
<Route 
  path="/admin" 
  element={
    <ProtectedRoute requireAdmin>
      <AdminPanel />
    </ProtectedRoute>
  } 
/>
```

---

## Безопасность

### Аутентификация
- Пароли хэшируются через bcrypt (Supabase Authentication)
- JWT токены с ограниченным сроком действия
- Автоматическое обновление токенов

### Авторизация
- RLS политики на уровне БД
- Проверка ролей на уровне клиента (ProtectedRoute)
- Ролевая модель доступа (RBAC)

### Защита данных
- Параметризованные запросы (защита от SQL-инъекций)
- Автоматическое экранирование в React (защита от XSS)
- Валидация данных на клиенте и сервере (CHECK constraints в БД)

### Хранение файлов
- Приватные файлы (songs) требуют подписанный URL
- Публичные файлы (covers, avatars) доступны через публичный URL
- RLS политики на Storage buckets

---

## Производительность

### Оптимизация запросов
- Индексы на часто используемых полях (username, role_id, album_id)
- Составные индексы для сложных запросов
- Пагинация для больших списков

### Кэширование
- React Query кэширует запросы к API
- Автоматическая инвалидация кэша при мутациях
- Локальное кэширование настроек в localStorage

### Оптимизация рендеринга
- React.memo для компонентов (если нужно)
- Ленивая загрузка компонентов (lazy loading)
- Виртуализация списков (если нужно)

---

## Развёртывание

### Сборка production
```bash
npm run build
```

**Результат:**
- Собранные файлы в `dist/`
- Оптимизированный JavaScript и CSS
- Минифицированный код

### Хостинг
- Статические файлы можно развернуть на Vercel, Netlify, или любой хостинг
- Supabase работает как backend (база данных, аутентификация, storage)

### Переменные окружения
- `VITE_SUPABASE_URL` — URL проекта Supabase
- `VITE_SUPABASE_PUBLISHABLE_KEY` — публичный ключ

---

## Основные технологии

**Frontend:**
- React 18 — UI библиотека
- TypeScript — типизация
- Vite — сборщик
- Tailwind CSS — стилизация
- Shadcn UI — компоненты
- React Router — маршрутизация
- React Query — управление запросами
- Recharts — графики

**Backend:**
- Supabase — BaaS платформа
- PostgreSQL — база данных
- Supabase Auth — аутентификация
- Supabase Storage — файловое хранилище

**Инструменты:**
- ESLint — линтер
- TypeScript — проверка типов
- Git — контроль версий

---

## Полезные команды

```bash
# Разработка
npm run dev

# Сборка
npm run build

# Превью production сборки
npm run preview

# Линтинг
npm run lint
```

---

## Структура файлов

```
src/
├── components/        # React компоненты
│   ├── ui/           # UI компоненты (Shadcn)
│   ├── Layout.tsx    # Общий макет
│   ├── MusicPlayer.tsx
│   └── ...
├── contexts/         # React Context
│   ├── PlayerContext.tsx
│   └── AppSettingsContext.tsx
├── hooks/            # Кастомные хуки
│   ├── useRole.ts
│   └── useTranslation.ts
├── integrations/     # Интеграции
│   └── supabase/
│       ├── client.ts # Supabase клиент
│       └── types.ts  # Типы БД
├── pages/            # Страницы
│   ├── Index.tsx
│   ├── Library.tsx
│   ├── Auth.tsx
│   └── ...
├── lib/              # Утилиты
│   ├── translations.ts
│   └── utils.ts
└── App.tsx           # Корневой компонент
```

---

## Типичные задачи

### Генерация типов из Supabase
```bash
# Использовать Supabase CLI для генерации типов
supabase gen types typescript --project-id YOUR_PROJECT_ID > src/integrations/supabase/types.ts
```

### Добавление новой страницы
1. Создать компонент в `src/pages/`
2. Добавить маршрут в `src/App.tsx`
3. Добавить навигацию в `src/components/Layout.tsx` (если нужно)
4. Добавить переводы в `src/lib/translations.ts` (если нужно)

### Добавление нового запроса к БД
1. Использовать `supabase.from("table").select()`
2. При необходимости использовать React Query для кэширования
3. Обработать ошибки через `try/catch`

### Добавление новой функции
1. Создать функцию в БД (если нужна серверная логика)
2. Вызвать функцию через `supabase.rpc("function_name")`
3. Обработать результат на клиенте

---

## Отладка

### Консоль браузера
- Логи запросов к Supabase
- Ошибки React
- Ошибки валидации

### Supabase Dashboard
- Просмотр данных в таблицах
- Тестирование RLS политик
- Просмотр логов запросов

### React DevTools
- Инспекция компонентов
- Просмотр состояния
- Профилирование производительности

