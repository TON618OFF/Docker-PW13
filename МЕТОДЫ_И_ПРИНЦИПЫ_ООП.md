# МЕТОДЫ И ПРИНЦИПЫ ООП
## Проект: Imperial Tunes

**Версия документа:** 1.0  
**Дата создания:** 09.11.2025  
**Технологический стек:** React + TypeScript, Tailwind CSS

---

## ОГЛАВЛЕНИЕ

1. [Общая информация](#общая-информация)
2. [Инкапсуляция](#инкапсуляция)
3. [Наследование](#наследование)
4. [Полиморфизм](#полиморфизм)
5. [Вёрстка и стилизация](#вёрстка-и-стилизация)
6. [Примеры использования методов](#примеры-использования-методов)

---

## ОБЩАЯ ИНФОРМАЦИЯ

Проект Imperial Tunes использует современные подходы к разработке на React с применением принципов объектно-ориентированного программирования:

- **Инкапсуляция** - через React Hooks, Context API и компонентную архитектуру
- **Наследование** - через расширение интерфейсов и использование `React.forwardRef`
- **Полиморфизм** - через варианты компонентов (variants) и условный рендеринг
- **Вёрстка** - через Tailwind CSS с компонентным подходом и адаптивным дизайном

---

## ИНКАПСУЛЯЦИЯ

Инкапсуляция в проекте реализована через изоляцию логики в отдельных модулях, хуках и контекстах.

### 1. Кастомные хуки (Custom Hooks)

Кастомные хуки инкапсулируют логику и состояние, предоставляя интерфейс для использования в компонентах.

#### Пример 1: Хук `useRole`

```typescript:src/hooks/useRole.ts
export const useRole = () => {
  const [role, setRole] = useState<string | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const fetchUserRole = async () => {
      // Инкапсулированная логика получения роли пользователя
      try {
        const user = (await supabase.auth.getUser()).data.user;
        if (!user) {
          setRole(null);
          setLoading(false);
          return;
        }

        const { data: userData, error } = await supabase
          .from("users")
          .select(`role:roles(role_name)`)
          .eq("id", user.id)
          .single();

        if (error) {
          setRole("слушатель");
        } else {
          setRole(userData?.role?.role_name || "слушатель");
        }
      } catch (error) {
        setRole("слушатель");
      } finally {
        setLoading(false);
      }
    };

    fetchUserRole();
    
    // Подписка на изменения аутентификации
    const { data: { subscription } } = supabase.auth.onAuthStateChange((event, session) => {
      if (event === 'SIGNED_IN' || event === 'SIGNED_OUT') {
        fetchUserRole();
      }
    });

    return () => subscription.unsubscribe();
  }, []);

  // Инкапсулированные вычисляемые свойства
  const isAdmin = role === "администратор";
  const isDistributor = role === "дистрибьютор";
  const isArtist = role === "артист";
  const isListener = role === "слушатель";
  const canManageContent = isAdmin || isDistributor || isArtist;
  const canAccessAdmin = isAdmin;

  // Публичный интерфейс хука
  return {
    role,
    loading,
    isAdmin,
    isDistributor,
    isArtist,
    isListener,
    canManageContent,
    canAccessAdmin
  };
};
```

**Описание:**
- Инкапсулирует логику получения и проверки роли пользователя
- Скрывает детали реализации (запросы к БД, подписки)
- Предоставляет простой интерфейс для компонентов
- Автоматически обновляется при изменении аутентификации

#### Пример 2: Хук `useTranslation`

```typescript:src/hooks/useTranslation.ts
export const useTranslation = () => {
  const { language } = useAppSettings();
  
  // Инкапсулированная функция перевода
  const t = (key: TranslationKey): string => {
    return translations[language]?.[key] || translations.ru[key] || key;
  };
  
  return { t, language };
};
```

**Описание:**
- Инкапсулирует логику перевода текста
- Автоматически использует текущий язык из контекста
- Предоставляет fallback на русский язык при отсутствии перевода

### 2. Context API (Контекст приложения)

Context API обеспечивает инкапсуляцию глобального состояния приложения.

#### Пример 3: `PlayerContext`

```typescript:src/contexts/PlayerContext.tsx
interface PlayerContextType {
  currentTrack: Track | null;
  setCurrentTrack: (track: Track | null) => void;
  playTrack: (track: Track) => void;
  playlist: Track[];
  setPlaylist: (tracks: Track[]) => void;
  currentTrackIndex: number;
  isShuffled: boolean;
  setIsShuffled: (shuffled: boolean) => void;
  shuffledPlaylist: Track[];
  nextTrack: () => void;
  previousTrack: () => void;
}

const PlayerContext = createContext<PlayerContextType | undefined>(undefined);

export const usePlayer = () => {
  const context = useContext(PlayerContext);
  if (!context) {
    throw new Error('usePlayer must be used within a PlayerProvider');
  }
  return context;
};

export const PlayerProvider: React.FC<PlayerProviderProps> = ({ children }) => {
  const [currentTrack, setCurrentTrack] = useState<Track | null>(null);
  const [playlist, setPlaylist] = useState<Track[]>([]);
  const [currentTrackIndex, setCurrentTrackIndex] = useState<number>(0);
  const [isShuffled, setIsShuffled] = useState<boolean>(false);
  const [shuffledPlaylist, setShuffledPlaylist] = useState<Track[]>([]);

  // Инкапсулированная функция перемешивания
  const shuffleArray = <T,>(array: T[]): T[] => {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  };

  // Инкапсулированная логика воспроизведения
  const playTrack = (track: Track) => {
    setCurrentTrack(track);
    const activePlaylist = isShuffled ? shuffledPlaylist : playlist;
    const index = activePlaylist.findIndex(t => t.id === track.id);
    if (index !== -1) {
      setCurrentTrackIndex(index);
    }
  };

  const nextTrack = () => {
    const activePlaylist = isShuffled ? shuffledPlaylist : playlist;
    if (activePlaylist.length > 0) {
      const nextIndex = (currentTrackIndex + 1) % activePlaylist.length;
      setCurrentTrackIndex(nextIndex);
      setCurrentTrack(activePlaylist[nextIndex]);
    }
  };

  const previousTrack = () => {
    const activePlaylist = isShuffled ? shuffledPlaylist : playlist;
    if (activePlaylist.length > 0) {
      const prevIndex = currentTrackIndex === 0 
        ? activePlaylist.length - 1 
        : currentTrackIndex - 1;
      setCurrentTrackIndex(prevIndex);
      setCurrentTrack(activePlaylist[prevIndex]);
    }
  };

  // Значение контекста
  const value: PlayerContextType = {
    currentTrack,
    setCurrentTrack,
    playTrack,
    playlist,
    setPlaylist,
    currentTrackIndex,
    setCurrentTrackIndex,
    isShuffled,
    setIsShuffled: handleSetIsShuffled,
    shuffledPlaylist,
    nextTrack,
    previousTrack,
  };

  return (
    <PlayerContext.Provider value={value}>
      {children}
    </PlayerContext.Provider>
  );
};
```

**Описание:**
- Инкапсулирует состояние и логику музыкального плеера
- Скрывает сложность управления плейлистом и перемешивания
- Предоставляет единый интерфейс для всех компонентов приложения
- Обеспечивает защиту от использования вне провайдера

### 3. Утилитные функции

Инкапсуляция переиспользуемой логики в утилитных функциях.

#### Пример 4: Функция `cn` (класс-менеджер)

```typescript:src/lib/utils.ts
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
```

**Описание:**
- Инкапсулирует логику объединения CSS классов
- Обрабатывает конфликты классов Tailwind
- Используется во всех компонентах для стилизации

---

## НАСЛЕДОВАНИЕ

В React наследование реализуется через расширение интерфейсов и использование `React.forwardRef`.

### 1. Расширение интерфейсов

#### Пример 5: Компонент `Button`

```typescript:src/components/ui/button.tsx
// Базовый интерфейс с расширением нативных свойств кнопки
export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button";
    return (
      <Comp 
        className={cn(buttonVariants({ variant, size, className }))} 
        ref={ref} 
        {...props} 
      />
    );
  },
);
Button.displayName = "Button";
```

**Описание:**
- Интерфейс `ButtonProps` наследует все свойства стандартного HTML-элемента `<button>`
- Добавляет дополнительные свойства: `variant`, `size`, `asChild`
- Использует `React.forwardRef` для передачи ref в нативный элемент
- Поддерживает все стандартные события и свойства кнопки

#### Пример 6: Компонент `Input`

```typescript:src/components/ui/input.tsx
const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className,
        )}
        ref={ref}
        {...props}
      />
    );
  },
);
Input.displayName = "Input";
```

**Описание:**
- Наследует все свойства стандартного `<input>`
- Добавляет стилизацию через Tailwind CSS
- Сохраняет все нативные функции (валидация, события и т.д.)

### 2. Варианты компонентов (Variants)

#### Пример 7: Варианты кнопки через `class-variance-authority`

```typescript:src/components/ui/button.tsx
const buttonVariants = cva(
  // Базовые классы
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
);
```

**Описание:**
- Определяет базовый стиль и варианты компонента
- Наследует базовые стили для всех вариантов
- Позволяет создавать разные варианты одного компонента
- Использует паттерн "Template Method" для вариативности

---

## ПОЛИМОРФИЗМ

Полиморфизм в проекте реализован через варианты компонентов, условный рендеринг и динамические компоненты.

### 1. Условный рендеринг

#### Пример 8: Условное отображение элементов навигации

```typescript:src/components/Layout.tsx
// Основные разделы, которые всегда показываются
const mainNavItems = [
  { path: "/", icon: Music2, label: t("common.home") },
  { path: "/library", icon: Library, label: t("common.library") },
  { path: "/playlists", icon: ListMusic, label: t("common.playlists") },
  { path: "/profile", icon: User, label: t("common.profile") },
];

// Дополнительные разделы (показываются условно)
const additionalNavItems = [
  { path: "/analytics", icon: BarChart3, label: t("common.analytics") },
  ...(canAccessAdmin ? [{ path: "/admin", icon: Crown, label: t('layout.adminPanel') }] : []),
  ...(isDistributor ? [{ path: "/applications", icon: User, label: t('layout.applications') }] : []),
];

// Все разделы для десктопной навигации
const navItems = [...mainNavItems, ...additionalNavItems];

// Полиморфный рендеринг навигации
<nav className="hidden md:flex items-center space-x-1">
  {navItems.map((item) => {
    const Icon = item.icon; // Динамическое использование компонента иконки
    const isActive = location.pathname === item.path;
    return (
      <Link key={item.path} to={item.path}>
        <Button
          variant="ghost"
          className={`gap-2 ${
            isActive
              ? "bg-primary/10 text-primary"
              : "text-muted-foreground hover:text-foreground"
          }`}
        >
          <Icon className="w-4 h-4" />
          {item.label}
        </Button>
      </Link>
    );
  })}
</nav>
```

**Описание:**
- Динамическое формирование списка навигации в зависимости от роли
- Полиморфное использование компонентов иконок через переменную
- Условное применение стилей в зависимости от состояния

### 2. Варианты компонентов (Polymorphic Components)

#### Пример 9: Полиморфный компонент Button с `asChild`

```typescript:src/components/ui/button.tsx
const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    // Полиморфизм: компонент может быть разным элементом
    const Comp = asChild ? Slot : "button";
    return (
      <Comp 
        className={cn(buttonVariants({ variant, size, className }))} 
        ref={ref} 
        {...props} 
      />
    );
  },
);
```

**Использование:**

```typescript
// Как обычная кнопка
<Button onClick={handleClick}>Нажми меня</Button>

// Как ссылка (полиморфизм)
<Button asChild>
  <Link to="/profile">Профиль</Link>
</Button>
```

**Описание:**
- Компонент может быть как `<button>`, так и любым другим элементом через `asChild`
- Сохраняет все стили и поведение независимо от типа элемента
- Реализует паттерн "Adapter" для адаптации к разным типам элементов

### 3. Динамические компоненты

#### Пример 10: Условный рендеринг компонентов в зависимости от роли

```typescript:src/components/BecomeArtistForm.tsx
const BecomeArtistForm = () => {
  const { role, isListener } = useRole();
  
  // Полиморфизм: разные компоненты для разных ролей
  if (!isListener) {
    return (
      <Card className="p-6">
        <div className="flex items-center gap-3 mb-4">
          <Award className="w-6 h-6 text-primary" />
          <h2 className="text-2xl font-bold">{t('becomeArtist.title')}</h2>
        </div>
        <p className="text-muted-foreground">
          {t('becomeArtist.alreadyRole', { 
            role: role === "артист" ? "артистом" : 
                  role === "дистрибьютор" ? "дистрибьютором" : 
                  "пользователем с расширенными правами" 
          })}
        </p>
      </Card>
    );
  }

  // Основной компонент для слушателей
  return (
    <Card className="p-6 space-y-6">
      {/* Форма заявки */}
    </Card>
  );
};
```

**Описание:**
- Один компонент ведёт себя по-разному в зависимости от роли пользователя
- Показывает разный UI для разных состояний
- Реализует паттерн "Strategy" для разных стратегий отображения

---

## ВЁРСТКА И СТИЛИЗАЦИЯ

Вёрстка в проекте реализована с использованием Tailwind CSS, компонентного подхода и адаптивного дизайна.

### 1. Система дизайна (Design System)

#### Пример 11: Настройка цветовой палитры

```css:src/index.css
@layer base {
  :root {
    /* Имперская тёмная тема */
    --background: 0 0% 7%;
    --foreground: 0 0% 98%;

    --card: 0 0% 9%;
    --card-foreground: 0 0% 98%;

    /* Имперский жёлтый (золотой) */
    --primary: 45 100% 50%;
    --primary-foreground: 0 0% 0%;

    /* Имперский оранжевый */
    --secondary: 25 95% 53%;
    --secondary-foreground: 0 0% 100%;

    /* Имперские градиенты */
    --gradient-primary: linear-gradient(135deg, hsl(45 100% 50%), hsl(25 95% 53%));
    --gradient-imperial: linear-gradient(135deg, hsl(45 100% 50%), hsl(25 95% 53%), hsl(20 90% 48%));
  }
}
```

**Описание:**
- Централизованная система цветов через CSS переменные
- Поддержка тёмной и светлой темы
- Градиенты и тени для создания визуальной глубины

### 2. Адаптивная вёрстка

#### Пример 12: Адаптивный Layout компонент

```typescript:src/components/Layout.tsx
return (
  <div className="min-h-screen flex flex-col bg-background">
    {/* Header с адаптивными размерами */}
    <header className="border-b border-border bg-card/50 backdrop-blur-xl sticky top-0 z-50">
      <div className="container mx-auto px-2 sm:px-4 h-14 sm:h-16 flex items-center justify-between">
        {/* Логотип с адаптивными размерами */}
        <div className="flex items-center space-x-2 sm:space-x-3 min-w-0">
          <div className="w-8 h-8 sm:w-10 sm:h-10 bg-primary/10 rounded-xl flex items-center justify-center flex-shrink-0">
            <Music2 className="w-5 h-5 sm:w-6 sm:h-6 text-primary" />
          </div>
          <h1 className="text-base sm:text-xl font-bold bg-gradient-to-r from-primary to-secondary bg-clip-text text-transparent truncate">
            ImperialTunes
          </h1>
        </div>

        {/* Десктопная навигация (скрыта на мобильных) */}
        <nav className="hidden md:flex items-center space-x-1">
          {navItems.map((item) => {
            const Icon = item.icon;
            const isActive = location.pathname === item.path;
            return (
              <Link key={item.path} to={item.path}>
                <Button variant="ghost" className="gap-2">
                  <Icon className="w-4 h-4" />
                  {item.label}
                </Button>
              </Link>
            );
          })}
        </nav>

        {/* Мобильное меню (показывается только на мобильных) */}
        <Sheet open={mobileMenuOpen} onOpenChange={setMobileMenuOpen}>
          <SheetTrigger asChild>
            <Button variant="ghost" size="sm" className="md:hidden">
              <Menu className="w-5 h-5" />
            </Button>
          </SheetTrigger>
        </Sheet>
      </div>
    </header>

    {/* Основной контент */}
    <main className="flex-1 container mx-auto px-2 sm:px-4 py-4 sm:py-6">
      <Outlet />
    </main>

    {/* Мобильная навигация внизу (только на мобильных) */}
    <nav className="md:hidden fixed bottom-0 left-0 right-0 border-t border-border bg-card/50 backdrop-blur-xl z-50">
      <div className="grid grid-cols-4 h-16">
        {mainNavItems.map((item) => {
          const Icon = item.icon;
          const isActive = location.pathname === item.path;
          return (
            <Link key={item.path} to={item.path}>
              <Button
                variant="ghost"
                className={`h-full flex flex-col items-center justify-center gap-1 ${
                  isActive ? "text-primary" : "text-muted-foreground"
                }`}
              >
                <Icon className="w-5 h-5" />
                <span className="text-xs">{item.label}</span>
              </Button>
            </Link>
          );
        })}
      </div>
    </nav>
  </div>
);
```

**Описание:**
- Адаптивные размеры через префиксы Tailwind (`sm:`, `md:`)
- Разные навигации для мобильных и десктопных устройств
- Адаптивные отступы и размеры шрифтов
- Использование `grid` и `flex` для гибкой вёрстки

### 3. Компонентная система стилей

#### Пример 13: Переиспользуемые стили через утилиты

```typescript:src/lib/utils.ts
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
```

**Использование в компонентах:**

```typescript
// Объединение классов с условной логикой
<Button
  className={cn(
    "base-classes",
    isActive && "active-classes",
    variant === "primary" && "primary-classes",
    className // Переданные извне классы
  )}
>
  Кнопка
</Button>
```

**Описание:**
- Утилита `cn` объединяет классы и разрешает конфликты
- Позволяет условно применять стили
- Интегрируется с Tailwind Merge для оптимизации

### 4. Градиенты и эффекты

#### Пример 14: Использование градиентов в заголовках

```typescript:src/components/Layout.tsx
<h1 className="text-base sm:text-xl font-bold bg-gradient-to-r from-primary to-secondary bg-clip-text text-transparent truncate">
  ImperialTunes
</h1>
```

**Описание:**
- Использование градиентов для текста через `bg-clip-text`
- Создание визуально привлекательных заголовков
- Соответствие имперской тематике проекта

### 5. Адаптивные breakpoints

```typescript:tailwind.config.ts
export default {
  theme: {
    screens: {
      "sm": "640px",
      "md": "768px",
      "lg": "1024px",
      "xl": "1280px",
      "2xl": "1400px",
    },
  },
}
```

**Использование:**

```typescript
// Скрыто на мобильных, видно на десктопе
<div className="hidden md:block">Десктоп контент</div>

// Видно на мобильных, скрыто на десктопе
<div className="md:hidden">Мобильный контент</div>

// Адаптивные размеры
<div className="text-sm md:text-base lg:text-lg">Адаптивный текст</div>
```

---

## ПРИМЕРЫ ИСПОЛЬЗОВАНИЯ МЕТОДОВ

### Таблица 1: Методы инкапсуляции

| № | Метод | Компонент/Файл | Описание |
|---|-------|----------------|----------|
| 1 | Custom Hook | `useRole.ts` | Инкапсуляция логики получения роли пользователя |
| 2 | Custom Hook | `useTranslation.ts` | Инкапсуляция логики перевода текста |
| 3 | Context API | `PlayerContext.tsx` | Инкапсуляция состояния музыкального плеера |
| 4 | Context API | `AppSettingsContext.tsx` | Инкапсуляция настроек приложения (тема, язык) |
| 5 | Утилитная функция | `utils.ts` | Инкапсуляция логики работы с CSS классами |

### Таблица 2: Методы наследования

| № | Метод | Компонент/Файл | Описание |
|---|-------|----------------|----------|
| 1 | Расширение интерфейсов | `button.tsx` | `ButtonProps extends React.ButtonHTMLAttributes` |
| 2 | Расширение интерфейсов | `input.tsx` | `React.ComponentProps<"input">` |
| 3 | React.forwardRef | `button.tsx` | Передача ref в нативный элемент |
| 4 | React.forwardRef | `input.tsx` | Передача ref в нативный элемент |
| 5 | Варианты компонентов | `button.tsx` | Наследование базовых стилей через `cva` |

### Таблица 3: Методы полиморфизма

| № | Метод | Компонент/Файл | Описание |
|---|-------|----------------|----------|
| 1 | Условный рендеринг | `Layout.tsx` | Динамическое формирование навигации |
| 2 | Полиморфный компонент | `button.tsx` | Использование `asChild` для разных элементов |
| 3 | Динамические компоненты | `BecomeArtistForm.tsx` | Разные UI для разных ролей |
| 4 | Условные стили | `Layout.tsx` | Применение стилей в зависимости от состояния |
| 5 | Варианты компонентов | `button.tsx` | Разные варианты через `variant` prop |

### Таблица 4: Методы вёрстки

| № | Метод | Компонент/Файл | Описание |
|---|-------|----------------|----------|
| 1 | Tailwind CSS | Все компоненты | Утилитарный подход к стилизации |
| 2 | Адаптивный дизайн | `Layout.tsx` | Использование breakpoints (`sm:`, `md:`, `lg:`) |
| 3 | Flexbox | `Layout.tsx` | Использование `flex` для расположения элементов |
| 4 | Grid | `Layout.tsx` | Использование `grid` для мобильной навигации |
| 5 | Градиенты | `Layout.tsx`, `index.css` | Использование CSS градиентов для текста |
| 6 | CSS переменные | `index.css` | Централизованная система цветов |
| 7 | Backdrop blur | `Layout.tsx` | Эффект размытия фона для header |
| 8 | Responsive typography | Все компоненты | Адаптивные размеры шрифтов |

---

## ЗАКЛЮЧЕНИЕ

Проект Imperial Tunes демонстрирует применение современных подходов к разработке React-приложений:

1. **Инкапсуляция** - логика изолирована в хуках, контекстах и утилитах
2. **Наследование** - интерфейсы расширяют нативные типы, компоненты наследуют функциональность
3. **Полиморфизм** - компоненты ведут себя по-разному в зависимости от пропсов и состояния
4. **Вёрстка** - современный подход с Tailwind CSS, адаптивным дизайном и компонентной системой

Все методы реализованы с использованием TypeScript для обеспечения типобезопасности и лучшей поддержки кода.

---