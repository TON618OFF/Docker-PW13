# 3. СПЕЦИАЛЬНАЯ ЧАСТЬ

## 3.1. Внешняя спецификация

Внешняя спецификация системы «ImperialTunes» определяет входные и выходные данные, форматы обмена информацией, интерфейсы взаимодействия с системой и структуру данных.

### 3.1.1. Входные данные системы

Входные данные системы включают информацию, поступающую от пользователей, внешних систем и автоматически генерируемые данные.

#### 3.1.1.1. Данные регистрации и аутентификации

**Данные регистрации нового пользователя:**
- **Email** (TEXT, NOT NULL) — адрес электронной почты пользователя, используется для входа и восстановления пароля.
- **Пароль** (TEXT, NOT NULL) — пароль пользователя (минимум 6 символов), автоматически хэшируется через bcrypt.
- **Имя пользователя** (VARCHAR(50), NOT NULL, UNIQUE) — уникальное имя пользователя (от 3 до 50 символов).
- **Имя** (VARCHAR(50), NULL) — имя пользователя (опционально).
- **Фамилия** (VARCHAR(50), NULL) — фамилия пользователя (опционально).

**Данные входа:**
- **Email** (TEXT, NOT NULL) — адрес электронной почты для аутентификации.
- **Пароль** (TEXT, NOT NULL) — пароль пользователя.

**Источник:** Пользователь через веб-интерфейс (страница авторизации).

#### 3.1.1.2. Данные профиля пользователя

**Обновление профиля:**
- **Имя пользователя** (VARCHAR(50), NOT NULL, UNIQUE) — новое имя пользователя.
- **Имя** (VARCHAR(50), NULL) — имя пользователя.
- **Фамилия** (VARCHAR(50), NULL) — фамилия пользователя.
- **Биография** (TEXT, NULL) — биография пользователя.
- **Аватар** (File, NULL) — изображение аватара (JPEG, PNG, WebP, максимум 5 МБ).

**Источник:** Пользователь через раздел «Профиль» или «Настройки».

#### 3.1.1.3. Музыкальные файлы и метаданные контента

**Загрузка трека:**
- **Аудиофайл** (Binary, NOT NULL) — аудиофайл в формате MP3, WAV, FLAC, OGG или M4A (максимум 50 МБ).
- **Название трека** (VARCHAR(100), NOT NULL) — название трека (от 1 до 100 символов).
- **Альбом** (UUID, NULL) — идентификатор альбома (опционально).
- **Жанры** (Array<UUID>, NULL) — массив идентификаторов жанров.
- **Порядок в альбоме** (INTEGER, NOT NULL) — порядковый номер трека в альбоме (больше 0).
- **Публичность** (BOOLEAN, NOT NULL) — статус публичности трека (по умолчанию TRUE).

**Создание альбома:**
- **Название альбома** (VARCHAR(100), NOT NULL) — название альбома (от 2 до 100 символов).
- **Дата релиза** (DATE, NOT NULL) — дата релиза альбома (от 1900-01-01 до текущей даты + 1 год).
- **Описание альбома** (TEXT, NULL) — описание альбома.
- **Обложка альбома** (File, NULL) — изображение обложки (JPEG, PNG, WebP, максимум 5 МБ).
- **Артист** (UUID, NOT NULL) — идентификатор артиста.

**Источник:** Артисты и дистрибьюторы через раздел «Библиотека» → «Мои треки» или «Профиль».

#### 3.1.1.4. Данные плейлистов

**Создание плейлиста:**
- **Название плейлиста** (VARCHAR(100), NOT NULL) — название плейлиста (от 2 до 100 символов).
- **Описание плейлиста** (TEXT, NULL) — описание плейлиста.
- **Видимость** (BOOLEAN, NOT NULL) — статус публичности плейлиста (по умолчанию FALSE — приватный).
- **Обложка плейлиста** (File, NULL) — изображение обложки (JPEG, PNG, WebP, максимум 5 МБ).

**Добавление треков в плейлист:**
- **ID плейлиста** (UUID, NOT NULL) — идентификатор плейлиста.
- **ID трека** (UUID, NOT NULL) — идентификатор трека.
- **Позиция** (INTEGER, NOT NULL) — порядковая позиция трека в плейлисте (больше 0).

**Источник:** Пользователи через раздел «Плейлисты».

#### 3.1.1.5. Заявки на статус артиста

**Подача заявки:**
- **Название артиста/группы** (VARCHAR(100), NOT NULL) — предполагаемое имя артиста (от 2 до 100 символов).
- **Биография артиста** (TEXT, NULL) — биография артиста.
- **Изображение артиста** (File, NULL) — изображение артиста (JPEG, PNG, WebP, максимум 5 МБ).
- **Жанр** (VARCHAR(50), NULL) — основной жанр артиста.
- **URL портфолио** (TEXT, NULL) — ссылка на портфолио артиста.
- **Социальные сети** (JSONB, NULL) — ссылки на социальные сети в формате JSON (Instagram, YouTube и т.д.).
- **Мотивационное письмо** (TEXT, NULL) — мотивационное письмо артиста.

**Источник:** Пользователи-заявители через раздел «Профиль» → «Стать артистом».

#### 3.1.1.6. Запросы на воспроизведение

**Запрос на воспроизведение трека:**
- **ID трека** (UUID, NOT NULL) — идентификатор трека для воспроизведения.
- **Длительность прослушивания** (INTEGER, NULL) — длительность прослушивания в секундах (неотрицательное число).
- **Признак завершения** (BOOLEAN, NULL) — признак завершения прослушивания трека (по умолчанию FALSE).

**Источник:** Медиа-плеер приложения при воспроизведении трека.

#### 3.1.1.7. Запросы на избранное

**Добавление/удаление из избранного:**
- **ID трека/альбома/плейлиста** (UUID, NOT NULL) — идентификатор элемента для добавления в избранное.
- **Тип элемента** (ENUM) — тип элемента: 'track', 'album', 'playlist'.
- **Действие** (ENUM) — действие: 'add' (добавить) или 'remove' (удалить).

**Источник:** Пользователи через интерфейс приложения (кнопка «Избранное»).

#### 3.1.1.8. Решения модераторов и дистрибьюторов

**Одобрение/отклонение заявки артиста:**
- **ID заявки** (UUID, NOT NULL) — идентификатор заявки на статус артиста.
- **Решение** (ENUM, NOT NULL) — решение: 'approved' (одобрена) или 'rejected' (отклонена).
- **Комментарий** (TEXT, NULL) — комментарий дистрибьютора при рассмотрении заявки.

**Источник:** Дистрибьюторы и модераторы через раздел «Заявки на артиста».

#### 3.1.1.9. Запросы на статистику и аналитику

**Параметры фильтрации:**
- **Период** (DATE RANGE, NULL) — диапазон дат для фильтрации статистики.
- **Жанры** (Array<UUID>, NULL) — массив идентификаторов жанров для фильтрации.
- **Артисты** (Array<UUID>, NULL) — массив идентификаторов артистов для фильтрации.
- **Тип статистики** (ENUM, NULL) — тип статистики: 'tracks', 'users', 'playlists', 'genres'.

**Источник:** Пользователи и администраторы через раздел «Аналитика».

#### 3.1.1.10. Настройки пользователя

**Настройки приложения:**
- **Язык интерфейса** (VARCHAR(10), NOT NULL) — язык интерфейса: 'ru' (русский) или 'en' (английский).
- **Тема оформления** (VARCHAR(10), NOT NULL) — тема оформления: 'dark' (тёмная) или 'light' (светлая).
- **Размер страниц пагинации** (INTEGER, NOT NULL) — количество элементов на странице (от 10 до 100).

**Источник:** Пользователи через раздел «Настройки».

### 3.1.2. Выходные данные системы

Выходные данные системы включают информацию, предоставляемую пользователям, результаты обработки запросов и автоматически генерируемые данные.

#### 3.1.2.1. Веб-интерфейс приложения

**HTML/CSS/JavaScript страницы:**
- **Главная страница** — обзор музыкального каталога, популярные треки, недавние альбомы.
- **Страница библиотеки** — каталог треков, альбомов и артистов с возможностью поиска и фильтрации.
- **Страница плейлистов** — список плейлистов пользователя и публичных плейлистов.
- **Страница аналитики** — графики прослушиваний, статистика по жанрам, популярные треки.
- **Страница профиля** — информация о пользователе, статистика, история прослушиваний.
- **Административная панель** — управление пользователями, контентом, жанрами и заявками.

**Формат:** HTML5, CSS3, JavaScript (ES6+), React компоненты.

**Получатель:** Веб-браузер пользователя.

#### 3.1.2.2. Сессия пользователя

**JWT токен:**
- **Токен** (JWT, NOT NULL) — JSON Web Token для авторизованного доступа к API.
- **Содержимое токена:**
  - Уникальный идентификатор пользователя (UUID)
  - Email пользователя
  - Роль пользователя
  - Дата истечения токена
- **Срок действия:** Ограниченный срок действия с автоматическим обновлением.

**Формат:** JWT (JSON Web Token).

**Получатель:** Клиентское приложение (хранится в localStorage или HttpOnly cookies).

#### 3.1.2.3. Профиль пользователя

**Данные профиля:**
- **ID пользователя** (UUID) — уникальный идентификатор пользователя.
- **Имя пользователя** (VARCHAR(50)) — имя пользователя.
- **Email** (TEXT) — адрес электронной почты.
- **Имя** (VARCHAR(50), NULL) — имя пользователя.
- **Фамилия** (VARCHAR(50), NULL) — фамилия пользователя.
- **Роль** (VARCHAR(50)) — роль пользователя: 'слушатель', 'артист', 'дистрибьютор', 'модератор', 'администратор'.
- **Аватар** (TEXT, NULL) — URL аватара пользователя.
- **Биография** (TEXT, NULL) — биография пользователя.
- **Дата регистрации** (TIMESTAMPTZ) — дата и время создания аккаунта.
- **Дата последнего входа** (TIMESTAMPTZ, NULL) — дата и время последнего входа.

**Формат:** JSON объект.

**Получатель:** Пользователь через раздел «Профиль».

#### 3.1.2.4. Аудиопоток и метаданные трека

**Аудиопоток:**
- **URL аудиофайла** (TEXT, NOT NULL) — публичный URL для доступа к аудиофайлу в Supabase Storage.
- **Метаданные трека:**
  - ID трека (UUID)
  - Название трека (VARCHAR(100))
  - Длительность трека (INTEGER, секунды)
  - Название альбома (VARCHAR(100), NULL)
  - Имя артиста (VARCHAR(100))
  - Обложка альбома (TEXT, NULL)
  - Жанры (Array<VARCHAR(50)>)
  - Количество прослушиваний (INTEGER)
  - Количество лайков (INTEGER)

**Формат:** Audio Stream (MP3, WAV, FLAC, OGG, M4A) + JSON метаданные.

**Получатель:** Медиа-плеер приложения.

#### 3.1.2.5. Загруженный контент

**Результат загрузки трека/альбома:**
- **ID трека/альбома** (UUID) — уникальный идентификатор созданного трека или альбома.
- **URL файлов** (TEXT) — публичные URL для доступа к аудиофайлам и обложкам в Supabase Storage.
- **Статус загрузки** (BOOLEAN) — успешность загрузки (TRUE — успешно, FALSE — ошибка).
- **Сообщение** (TEXT, NULL) — сообщение об ошибке (если есть).

**Формат:** JSON объект.

**Получатель:** Система, пользователи (артисты, дистрибьюторы).

#### 3.1.2.6. Плейлисты

**Созданные/обновленные плейлисты:**
- **ID плейлиста** (UUID) — уникальный идентификатор плейлиста.
- **Название плейлиста** (VARCHAR(100))
- **Описание плейлиста** (TEXT, NULL)
- **Владелец** (UUID) — идентификатор пользователя-владельца.
- **Список треков** (Array<UUID>) — массив идентификаторов треков в плейлисте.
- **Порядок треков** (Array<INTEGER>) — порядковые позиции треков в плейлисте.
- **Обложка плейлиста** (TEXT, NULL) — URL обложки плейлиста.
- **Количество подписчиков** (INTEGER) — количество подписчиков плейлиста.
- **Общая длительность** (INTEGER) — общая длительность плейлиста в секундах.

**Формат:** JSON объект или массив объектов.

**Получатель:** Пользователь, система.

#### 3.1.2.7. История прослушиваний

**Записи истории:**
- **ID записи** (UUID) — уникальный идентификатор записи истории.
- **ID пользователя** (UUID) — идентификатор пользователя.
- **ID трека** (UUID) — идентификатор прослушанного трека.
- **Дата и время прослушивания** (TIMESTAMPTZ) — дата и время прослушивания трека.
- **Длительность прослушивания** (INTEGER, NULL) — длительность прослушивания в секундах.
- **Признак завершения** (BOOLEAN) — признак завершения прослушивания трека.

**Обновленные счетчики:**
- **Количество прослушиваний трека** (INTEGER) — обновленное количество прослушиваний трека (автоматически увеличивается триггером).

**Формат:** JSON массив объектов.

**Получатель:** Система (автоматически), пользователь через раздел «Профиль» → «История прослушиваний».

#### 3.1.2.8. Избранное

**Обновленные записи избранного:**
- **ID записи** (UUID) — уникальный идентификатор записи избранного.
- **ID пользователя** (UUID) — идентификатор пользователя.
- **ID элемента** (UUID) — идентификатор трека, альбома или плейлиста.
- **Тип элемента** (ENUM) — тип элемента: 'track', 'album', 'playlist'.
- **Действие** (ENUM) — выполненное действие: 'added' (добавлено) или 'removed' (удалено).
- **Дата добавления** (TIMESTAMPTZ) — дата и время добавления в избранное.

**Формат:** JSON объект с полями success, action, error.

**Получатель:** Система, пользователь.

#### 3.1.2.9. Статус заявок на артиста

**Результат рассмотрения заявки:**
- **ID заявки** (UUID) — уникальный идентификатор заявки.
- **Статус заявки** (VARCHAR(20)) — статус: 'pending' (на рассмотрении), 'approved' (одобрена), 'rejected' (отклонена).
- **ID артиста** (UUID, NULL) — идентификатор созданного артиста (если заявка одобрена).
- **Роль пользователя** (VARCHAR(50)) — обновленная роль пользователя (если заявка одобрена — 'артист').
- **Комментарий дистрибьютора** (TEXT, NULL) — комментарий при рассмотрении заявки.
- **Дата рассмотрения** (TIMESTAMPTZ, NULL) — дата и время рассмотрения заявки.

**Формат:** JSON объект с полями success, message, artist_id, error.

**Получатель:** Система, пользователь-заявитель, дистрибьютор.

#### 3.1.2.10. Статистика и аналитика

**Графики и отчеты:**
- **График прослушиваний по времени** — количество прослушиваний за выбранный период (день, неделя, месяц).
- **Распределение по жанрам** — круговая диаграмма с процентом прослушиваний для каждого жанра.
- **Популярные треки** — список наиболее популярных треков с количеством прослушиваний.
- **Статистика пользователя:**
  - Количество созданных плейлистов (INTEGER)
  - Общее количество прослушиваний (INTEGER)
  - Количество уникальных прослушанных треков (INTEGER)
- **Статистика трека:**
  - Количество прослушиваний (INTEGER)
  - Количество лайков (INTEGER)
  - Уровень популярности (VARCHAR(20)) — 'Новый', 'Средний', 'Популярный'

**Формат:** JSON объекты с данными для графиков (Recharts), таблицы данных.

**Получатель:** Пользователи, администраторы через раздел «Аналитика».

#### 3.1.2.11. Уведомления

**Сообщения о статусе операций:**
- **Тип уведомления** (ENUM) — тип: 'success' (успех), 'error' (ошибка), 'warning' (предупреждение), 'info' (информация).
- **Сообщение** (TEXT) — текст уведомления.
- **Длительность отображения** (INTEGER) — время отображения уведомления в миллисекундах.

**Формат:** JSON объект или Toast-уведомление (через библиотеку Sonner).

**Получатель:** Пользователи через интерфейс приложения.

#### 3.1.2.12. Экспортированные данные

**Форматы экспорта:**
- **CSV файл** — данные в формате CSV (разделитель запятая, кодировка UTF-8).
- **JSON файл** — данные в формате JSON (валидный JSON с массивами объектов).
- **SQL дамп** — SQL дамп базы данных для бэкапа.

**Типы экспортируемых данных:**
- Треки (список треков с метаданными)
- Пользователи (список пользователей с профилями)
- Статистика (данные аналитики)
- Плейлисты (список плейлистов с треками)

**Формат:** Файлы (CSV, JSON, SQL).

**Получатель:** Пользователи, администраторы через раздел «Аналитика» → «Экспорт».

#### 3.1.2.13. Резервные копии

**Структура бэкапа:**
- **База данных** — SQL дамп или JSON данные всех таблиц.
- **Storage файлы** — все файлы из buckets (songs, covers, avatars).
- **Метаданные бэкапа** — информация о дате создания, размере, количестве файлов.

**Формат:** Архив tar.gz или директория с файлами.

**Получатель:** Система хранения (локально или облачное хранилище).

### 3.1.3. Форматы данных

#### 3.1.3.1. JSON формат

Все API-запросы и ответы используют формат JSON (JavaScript Object Notation):

**Пример запроса регистрации:**
```json
{
  "email": "user@example.com",
  "password": "password123",
  "username": "username",
  "first_name": "Имя",
  "last_name": "Фамилия"
}
```

**Пример ответа с данными трека:**
```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "track_title": "Название трека",
  "track_duration": 180,
  "track_play_count": 1250,
  "track_like_count": 45,
  "track_audio_url": "https://...supabase.co/storage/v1/object/public/songs/...",
  "album": {
    "id": "660e8400-e29b-41d4-a716-446655440001",
    "album_title": "Название альбома",
    "album_cover_url": "https://...supabase.co/storage/v1/object/public/covers/...",
    "artist": {
      "id": "770e8400-e29b-41d4-a716-446655440002",
      "artist_name": "Имя артиста"
    }
  },
  "genres": [
    {
      "id": "880e8400-e29b-41d4-a716-446655440003",
      "genre_name": "Рок"
    }
  ]
}
```

#### 3.1.3.2. Форматы файлов

**Аудио файлы:**
- **MP3** (audio/mpeg) — максимальный размер 50 МБ
- **WAV** (audio/wav) — максимальный размер 50 МБ
- **FLAC** (audio/flac) — максимальный размер 50 МБ
- **OGG** (audio/ogg) — максимальный размер 50 МБ
- **M4A** (audio/mp4) — максимальный размер 50 МБ

**Изображения:**
- **JPEG** (image/jpeg) — максимальный размер 5 МБ
- **PNG** (image/png) — максимальный размер 5 МБ
- **WebP** (image/webp) — максимальный размер 5 МБ

#### 3.1.3.3. Типы данных базы данных

**Основные типы:**
- **UUID** — уникальный идентификатор (генерируется автоматически через `uuid_generate_v4()`)
- **VARCHAR(n)** — строка переменной длины (n — максимальная длина)
- **TEXT** — строка неограниченной длины
- **INTEGER** — целое число
- **BOOLEAN** — логическое значение (TRUE/FALSE)
- **DATE** — дата (формат: YYYY-MM-DD)
- **TIMESTAMPTZ** — дата и время с часовым поясом (формат: ISO 8601)
- **JSONB** — данные в формате JSON (бинарный формат PostgreSQL)

**ENUM типы:**
- **app_role** — роли пользователей: 'слушатель', 'администратор', 'артист', 'дистрибьютор', 'модератор'
- **audio_format** — форматы аудио: 'mp3', 'wav', 'flac', 'ogg', 'm4a'
- **application_status** — статусы заявок: 'pending', 'approved', 'rejected'
- **action_type** — типы действий аудита: 'INSERT', 'UPDATE', 'DELETE', 'SELECT', 'LOGIN', 'LOGOUT'

### 3.1.4. Интерфейсы взаимодействия

#### 3.1.4.1. REST API (Supabase)

Система использует автоматически генерируемый REST API от Supabase для всех таблиц базы данных:

**Базовый URL:** `https://[project-ref].supabase.co/rest/v1/`

**Методы HTTP:**
- **GET** — получение данных (SELECT)
- **POST** — создание новых записей (INSERT)
- **PATCH** — обновление записей (UPDATE)
- **DELETE** — удаление записей (DELETE)

**Заголовки:**
- `apikey: [ANON_KEY или SERVICE_ROLE_KEY]` — ключ API для аутентификации
- `Authorization: Bearer [JWT_TOKEN]` — JWT токен для авторизованных запросов
- `Content-Type: application/json` — тип содержимого для JSON данных
- `Prefer: return=representation` — возвращать созданные/обновленные данные

**Пример запроса:**
```http
GET /rest/v1/tracks?select=*,album:albums(*,artist:artists(*))&is_public=eq.true
Authorization: Bearer [JWT_TOKEN]
apikey: [ANON_KEY]
```

#### 3.1.4.2. Supabase Storage API

**Базовый URL:** `https://[project-ref].supabase.co/storage/v1/object/`

**Операции:**
- **Загрузка файла:** `POST /storage/v1/object/[bucket]/[path]`
- **Скачивание файла:** `GET /storage/v1/object/[bucket]/[path]`
- **Удаление файла:** `DELETE /storage/v1/object/[bucket]/[path]`
- **Список файлов:** `GET /storage/v1/object/list/[bucket]`

**Buckets:**
- `songs` — аудио файлы (приватный)
- `covers` — обложки альбомов и артистов (публичный)
- `avatars` — аватары пользователей (публичный)

#### 3.1.4.3. Supabase Authentication API

**Базовый URL:** `https://[project-ref].supabase.co/auth/v1/`

**Операции:**
- **Регистрация:** `POST /auth/v1/signup`
- **Вход:** `POST /auth/v1/token`
- **Выход:** `POST /auth/v1/logout`
- **Восстановление пароля:** `POST /auth/v1/recover`
- **Обновление токена:** `POST /auth/v1/token?grant_type=refresh_token`

### 3.1.5. Ограничения и валидация

#### 3.1.5.1. Ограничения на входные данные

**Длина строк:**
- Имя пользователя: от 3 до 50 символов
- Название трека: от 1 до 100 символов
- Название альбома: от 2 до 100 символов
- Название плейлиста: от 2 до 100 символов
- Название артиста: от 2 до 100 символов
- Название жанра: от 2 до 50 символов

**Диапазоны значений:**
- Длительность трека: от 1 до 7200 секунд (2 часа)
- Дата релиза альбома: от 1900-01-01 до текущей даты + 1 год
- Порядок трека в альбоме: больше 0
- Порядок трека в плейлисте: больше 0
- Количество прослушиваний: неотрицательное число (>= 0)
- Количество лайков: неотрицательное число (>= 0)

**Размеры файлов:**
- Аудио файлы: максимум 50 МБ
- Изображения (обложки, аватары): максимум 5 МБ

#### 3.1.5.2. Ограничения на выходные данные

**Лимиты запросов:**
- Максимальное количество записей в одном запросе: 1000 (настраивается через параметр `limit`)
- Максимальная глубина вложенных JOIN: 3 уровня
- Максимальное время выполнения запроса: 30 секунд

**Пагинация:**
- Размер страницы по умолчанию: 20 элементов
- Минимальный размер страницы: 10 элементов
- Максимальный размер страницы: 100 элементов

### 3.1.6. Бизнес-процессы

Бизнес-процессы системы «ImperialTunes» описывают основные сценарии взаимодействия пользователей с системой и автоматизированные процессы обработки данных.

#### 3.1.6.1. Процесс регистрации и аутентификации

**Описание:** Пользователь регистрируется в системе, получает доступ к базовым функциям, затем может войти в систему для работы с расширенными возможностями.

**Шаги процесса:**
1. Пользователь заполняет форму регистрации (email, пароль, имя пользователя).
2. Система валидирует данные (проверка формата email, длины пароля, уникальности username).
3. Supabase Authentication создаёт запись в `auth.users` и хэширует пароль через bcrypt.
4. Триггер `handle_new_user()` автоматически создаёт профиль в `public.users` с ролью «слушатель».
5. Пользователь получает JWT токен и перенаправляется на главную страницу.

**Входные данные:** Email, пароль, имя пользователя, имя, фамилия (опционально).

**Выходные данные:** JWT токен, профиль пользователя, статус регистрации.

#### 3.1.6.2. Процесс загрузки музыкального контента

**Описание:** Артист или дистрибьютор загружает трек в систему, система обрабатывает файл и создаёт запись в базе данных.

**Шаги процесса:**
1. Пользователь с ролью «артист» или «дистрибьютор» выбирает аудиофайл для загрузки.
2. Система валидирует файл (формат, размер до 50 МБ).
3. Файл загружается в Supabase Storage bucket `songs`.
4. Система создаёт запись в таблице `tracks` с метаданными (название, длительность, жанры).
5. Триггер `audit_changes()` логирует операцию в `audit_log`.
6. Трек становится доступным для прослушивания (если `is_public = TRUE`).

**Входные данные:** Аудиофайл, название трека, альбом (опционально), жанры, публичность.

**Выходные данные:** ID трека, URL аудиофайла, статус загрузки.

#### 3.1.6.3. Процесс воспроизведения трека

**Описание:** Пользователь воспроизводит трек, система записывает историю прослушивания и обновляет статистику.

**Шаги процесса:**
1. Пользователь выбирает трек для воспроизведения.
2. Система получает URL аудиофайла из Storage и метаданные трека из БД.
3. Медиа-плеер загружает и воспроизводит аудиофайл.
4. При завершении прослушивания создаётся запись в `listening_history`.
5. Триггер `listening_history_trigger` автоматически увеличивает `track_play_count` в таблице `tracks`.

**Входные данные:** ID трека, длительность прослушивания, признак завершения.

**Выходные данные:** Аудиопоток, метаданные трека, обновлённая статистика прослушиваний.

#### 3.1.6.4. Процесс создания плейлиста

**Описание:** Пользователь создаёт плейлист и добавляет в него треки.

**Шаги процесса:**
1. Пользователь создаёт новый плейлист (название, описание, видимость).
2. Система создаёт запись в таблице `playlists`.
3. Пользователь добавляет треки в плейлист через интерфейс.
4. Система создаёт связи в таблице `playlist_tracks` с указанием порядка треков.
5. Триггер `audit_changes()` логирует создание плейлиста.

**Входные данные:** Название плейлиста, описание, видимость, список треков с порядком.

**Выходные данные:** ID плейлиста, список треков в плейлисте, общая длительность.

#### 3.1.6.5. Процесс подачи заявки на статус артиста

**Описание:** Пользователь подаёт заявку на получение статуса артиста, дистрибьютор рассматривает заявку.

**Шаги процесса:**
1. Пользователь заполняет форму заявки (название артиста, биография, жанр, портфолио).
2. Система создаёт запись в таблице `artist_applications` со статусом `pending`.
3. Дистрибьютор просматривает заявку в разделе «Заявки на артиста».
4. Дистрибьютор одобряет или отклоняет заявку через функцию `approve_artist_application()` или `reject_artist_application()`.
5. При одобрении система создаёт запись в таблице `artists` и обновляет роль пользователя на «артист».
6. Пользователь получает уведомление о результате рассмотрения заявки.

**Входные данные:** Название артиста, биография, изображение, жанр, портфолио, мотивационное письмо.

**Выходные данные:** Статус заявки, ID артиста (при одобрении), комментарий дистрибьютора.

#### 3.1.6.6. Процесс аналитики и статистики

**Описание:** Система собирает статистику прослушиваний и предоставляет аналитические данные пользователям и администраторам.

**Шаги процесса:**
1. Система автоматически собирает данные из `listening_history`, `tracks`, `playlists`.
2. Представления (views) `user_statistics`, `track_statistics` вычисляют агрегированные данные.
3. Пользователь запрашивает статистику через раздел «Аналитика».
4. Система формирует графики и отчёты на основе данных из представлений.
5. Данные визуализируются через библиотеку Recharts.

**Входные данные:** Параметры фильтрации (период, жанры, артисты).

**Выходные данные:** Графики прослушиваний, распределение по жанрам, популярные треки, статистика пользователя.

### 3.1.7. Методы и сценарии использования

#### 3.1.7.1. Сценарий использования: Слушатель

**Цель:** Прослушивание музыки, создание плейлистов, управление избранным.

**Основные действия:**
1. **Регистрация и вход:**
   - Регистрация через форму с email и паролем.
   - Автоматическое создание профиля с ролью «слушатель».
   - Вход в систему через email и пароль.

2. **Просмотр каталога:**
   - Просмотр библиотеки треков с фильтрацией по жанрам, артистам, альбомам.
   - Поиск треков по названию, артисту, альбому.
   - Сортировка по популярности, дате добавления, количеству прослушиваний.

3. **Воспроизведение музыки:**
   - Выбор трека для воспроизведения.
   - Управление воспроизведением (пауза, перемотка, громкость).
   - Переключение между треками в альбоме или плейлисте.

4. **Управление плейлистами:**
   - Создание нового плейлиста.
   - Добавление треков в плейлист.
   - Редактирование порядка треков в плейлисте.
   - Удаление треков из плейлиста.
   - Удаление плейлиста.

5. **Работа с избранным:**
   - Добавление треков, альбомов, плейлистов в избранное.
   - Просмотр списка избранного.
   - Удаление элементов из избранного.

6. **Просмотр статистики:**
   - Просмотр истории прослушиваний.
   - Просмотр статистики прослушанных треков.
   - Просмотр графиков активности.

#### 3.1.7.2. Сценарий использования: Артист

**Цель:** Загрузка музыкального контента, управление альбомами и треками.

**Основные действия:**
1. **Подача заявки на статус артиста:**
   - Заполнение формы заявки с информацией об артисте.
   - Загрузка изображения артиста.
   - Ожидание рассмотрения заявки дистрибьютором.

2. **Загрузка контента:**
   - Создание альбома (название, дата релиза, описание, обложка).
   - Загрузка треков в альбом (аудиофайл, название, порядок, жанры).
   - Редактирование метаданных треков и альбомов.
   - Удаление треков и альбомов.

3. **Управление контентом:**
   - Просмотр списка загруженных треков.
   - Просмотр статистики прослушиваний своих треков.
   - Изменение публичности треков и альбомов.

#### 3.1.7.3. Сценарий использования: Дистрибьютор

**Цель:** Рассмотрение заявок на статус артиста, управление контентом.

**Основные действия:**
1. **Рассмотрение заявок:**
   - Просмотр списка заявок на статус артиста.
   - Просмотр детальной информации о заявке.
   - Одобрение или отклонение заявки с комментарием.

2. **Управление контентом:**
   - Просмотр всех треков и альбомов в системе.
   - Редактирование метаданных контента.
   - Управление жанрами.

#### 3.1.7.4. Сценарий использования: Администратор

**Цель:** Полное управление системой, пользователями, контентом.

**Основные действия:**
1. **Управление пользователями:**
   - Просмотр списка всех пользователей.
   - Изменение ролей пользователей.
   - Деактивация аккаунтов пользователей.

2. **Управление контентом:**
   - Просмотр и редактирование всех треков, альбомов, артистов.
   - Управление жанрами.
   - Удаление контента.

3. **Аналитика:**
   - Просмотр общей статистики системы.
   - Экспорт данных в CSV, JSON, SQL.
   - Мониторинг активности пользователей.

### 3.1.8. Тесты на уровне требований

Тесты на уровне требований проверяют соответствие системы функциональным и нефункциональным требованиям.

#### 3.1.8.1. Функциональные требования

**Требование FR-1: Регистрация и аутентификация пользователей**

**Тест FR-1.1:** Регистрация нового пользователя
- **Предусловия:** Пользователь не зарегистрирован в системе.
- **Действия:** Заполнение формы регистрации с валидными данными (email, пароль, username).
- **Ожидаемый результат:** Пользователь успешно зарегистрирован, создан профиль с ролью «слушатель», получен JWT токен.

**Тест FR-1.2:** Вход в систему
- **Предусловия:** Пользователь зарегистрирован в системе.
- **Действия:** Ввод email и пароля в форму входа.
- **Ожидаемый результат:** Пользователь успешно авторизован, получен JWT токен, перенаправление на главную страницу.

**Тест FR-1.3:** Валидация данных при регистрации
- **Предусловия:** Пользователь не зарегистрирован.
- **Действия:** Попытка регистрации с невалидными данными (короткий пароль, невалидный email, короткий username).
- **Ожидаемый результат:** Система отображает сообщения об ошибках валидации, регистрация не выполняется.

**Требование FR-2: Управление музыкальным контентом**

**Тест FR-2.1:** Загрузка трека
- **Предусловия:** Пользователь имеет роль «артист» или «дистрибьютор».
- **Действия:** Загрузка аудиофайла с метаданными (название, жанры).
- **Ожидаемый результат:** Трек успешно загружен, создана запись в БД, файл сохранён в Storage, трек доступен для прослушивания.

**Тест FR-2.2:** Создание альбома
- **Предусловия:** Пользователь имеет роль «артист» или «дистрибьютор».
- **Действия:** Создание альбома с названием, датой релиза, описанием, обложкой.
- **Ожидаемый результат:** Альбом успешно создан, создана запись в БД, обложка сохранена в Storage.

**Требование FR-3: Воспроизведение музыки**

**Тест FR-3.1:** Воспроизведение трека
- **Предусловия:** Пользователь авторизован, трек доступен в системе.
- **Действия:** Выбор трека для воспроизведения.
- **Ожидаемый результат:** Трек воспроизводится, создана запись в `listening_history`, обновлён счётчик прослушиваний.

**Требование FR-4: Управление плейлистами**

**Тест FR-4.1:** Создание плейлиста
- **Предусловия:** Пользователь авторизован.
- **Действия:** Создание нового плейлиста с названием и описанием.
- **Ожидаемый результат:** Плейлист успешно создан, создана запись в БД.

**Тест FR-4.2:** Добавление треков в плейлист
- **Предусловия:** Плейлист создан, треки доступны в системе.
- **Действия:** Добавление треков в плейлист с указанием порядка.
- **Ожидаемый результат:** Треки добавлены в плейлист, созданы связи в `playlist_tracks`.

**Требование FR-5: Ролевая модель доступа (RBAC)**

**Тест FR-5.1:** Доступ к функциям в зависимости от роли
- **Предусловия:** Пользователи с разными ролями зарегистрированы в системе.
- **Действия:** Попытка доступа к функциям, требующим определённых ролей (загрузка трека, администрирование).
- **Ожидаемый результат:** Доступ предоставляется только пользователям с соответствующими ролями, остальные получают сообщение об отказе в доступе.

#### 3.1.8.2. Нефункциональные требования

**Требование NFR-1: Производительность**

**Тест NFR-1.1:** Время загрузки страниц
- **Предусловия:** Система работает в нормальном режиме.
- **Действия:** Загрузка основных страниц приложения (главная, библиотека, профиль).
- **Ожидаемый результат:** Время загрузки страницы не превышает 2 секунд.

**Тест NFR-1.2:** Время отклика API
- **Предусловия:** Система работает в нормальном режиме.
- **Действия:** Выполнение типичных запросов к API (получение списка треков, создание плейлиста).
- **Ожидаемый результат:** Время отклика API не превышает 500 мс.

**Требование NFR-2: Безопасность**

**Тест NFR-2.1:** Защита от SQL-инъекций
- **Предусловия:** Система работает в нормальном режиме.
- **Действия:** Попытка выполнения SQL-инъекции через входные данные.
- **Ожидаемый результат:** SQL-инъекция блокируется, параметризованные запросы предотвращают выполнение вредоносного кода.

**Тест NFR-2.2:** Защита от XSS
- **Предусловия:** Система работает в нормальном режиме.
- **Действия:** Попытка внедрения JavaScript-кода через входные данные.
- **Ожидаемый результат:** XSS-атака блокируется, React автоматически экранирует данные при рендеринге.

**Тест NFR-2.3:** Row Level Security (RLS)
- **Предусловия:** Пользователи с разными ролями зарегистрированы в системе.
- **Действия:** Попытка доступа к данным других пользователей через API.
- **Ожидаемый результат:** RLS политики блокируют доступ к чужим данным, пользователь видит только свои данные или публичные данные.

**Требование NFR-3: Масштабируемость**

**Тест NFR-3.1:** Работа с большим объёмом данных
- **Предусловия:** В системе загружено большое количество треков (1000+).
- **Действия:** Загрузка списка треков с пагинацией.
- **Ожидаемый результат:** Система корректно обрабатывает запросы с пагинацией, время отклика остаётся приемлемым.

---

## 3.2. Проектирование

Проектирование системы «ImperialTunes» включает описание структуры базы данных, архитектуры приложения, пользовательских интерфейсов и схемы тестирования.

### 3.2.1. ER-диаграмма и словарь данных

#### 3.2.1.1. ER-диаграмма базы данных

ER-диаграмма (Entity-Relationship Diagram) представляет структуру базы данных и связи между сущностями.

**Основные сущности:**
- **users** (Пользователи) — профили пользователей системы
- **roles** (Роли) — роли пользователей (слушатель, артист, администратор, дистрибьютор, модератор)
- **artists** (Артисты) — информация об артистах
- **albums** (Альбомы) — музыкальные альбомы
- **tracks** (Треки) — музыкальные треки
- **genres** (Жанры) — музыкальные жанры
- **playlists** (Плейлисты) — пользовательские плейлисты
- **listening_history** (История прослушиваний) — записи о прослушивании треков
- **favorites_tracks** (Избранные треки) — избранные треки пользователей
- **favorites_albums** (Избранные альбомы) — избранные альбомы пользователей
- **favorites_playlists** (Избранные плейлисты) — избранные плейлисты пользователей
- **artist_applications** (Анкеты артистов) — заявки на получение статуса артиста
- **audit_log** (Лог аудита) — записи об изменениях в системе

**Связи между сущностями:**

```
users (1) ────< (N) artists
users (1) ────< (N) playlists
users (1) ────< (N) listening_history
users (1) ────< (N) favorites_tracks
users (1) ────< (N) favorites_albums
users (1) ────< (N) favorites_playlists
users (1) ────< (N) artist_applications
users (1) ────< (N) tracks (uploaded_by)
users (1) ────< (N) albums (created_by)

roles (1) ────< (N) users

artists (1) ────< (N) albums
artists (1) ────< (N) tracks (через albums)

albums (1) ────< (N) tracks

tracks (N) ────< (M) genres (через track_genres)
tracks (N) ────< (M) playlists (через playlist_tracks)
tracks (1) ────< (N) listening_history
tracks (1) ────< (N) favorites_tracks

playlists (1) ────< (N) favorites_playlists
albums (1) ────< (N) favorites_albums
```

**Типы связей:**
- **Один-ко-многим (1:N):** users → artists, users → playlists, artists → albums, albums → tracks
- **Многие-ко-многим (M:N):** tracks ↔ genres (через track_genres), tracks ↔ playlists (через playlist_tracks)

#### 3.2.1.2. Словарь данных

Словарь данных содержит описание всех таблиц, полей, ограничений и связей базы данных. Полный словарь данных представлен в отдельном документе `СЛОВАРЬ_ДАННЫХ.md`.

**Ключевые таблицы:**

**Таблица `users`:**
- Связь с `auth.users` (Supabase Authentication) через `id`
- Связь с `roles` через `role_id`
- Уникальное поле `username`
- Ограничения: длина username от 3 до 50 символов, язык 'ru' или 'en'

**Таблица `tracks`:**
- Связь с `albums` через `album_id` (ON DELETE CASCADE)
- Связь с `users` через `uploaded_by` (ON DELETE SET NULL)
- Ограничения: длительность от 1 до 7200 секунд, название от 1 до 100 символов

**Таблица `playlists`:**
- Связь с `users` через `user_id` (ON DELETE CASCADE)
- Связь с `tracks` через таблицу `playlist_tracks` (M:N)

**Таблица `track_genres`:**
- Связь M:N между `tracks` и `genres`
- Уникальная комбинация `(track_id, genre_id)`

### 3.2.2. Структурная схема БД и обоснование ключевых ограничений

#### 3.2.2.1. Структурная схема базы данных

База данных состоит из 15 основных таблиц, организованных в схему `public`:

```
public/
├── roles                    # Роли пользователей
├── users                    # Профили пользователей
├── artists                  # Артисты
├── genres                   # Жанры
├── albums                   # Альбомы
├── tracks                   # Треки
├── playlists                # Плейлисты
├── track_genres             # Связь трек-жанр (M:N)
├── playlist_tracks          # Связь плейлист-трек (M:N)
├── listening_history        # История прослушиваний
├── favorites_tracks         # Избранные треки
├── favorites_albums         # Избранные альбомы
├── favorites_playlists      # Избранные плейлисты
├── artist_applications      # Заявки на статус артиста
└── audit_log                # Лог аудита
```

**Представления (Views):**
- `album_duration` — длительность альбомов и количество треков
- `playlist_duration` — длительность плейлистов и количество треков
- `user_statistics` — статистика пользователей
- `track_statistics` — статистика треков с уровнем популярности

#### 3.2.2.2. Обоснование ключевых ограничений

**Ограничения целостности (CHECK constraints):**

1. **Длина строковых полей:**
   - `username`: от 3 до 50 символов — обеспечивает уникальность и удобство использования
   - `track_title`: от 1 до 100 символов — разумные ограничения для названий треков
   - `album_title`: от 2 до 100 символов — минимальная длина для валидного названия альбома
   - `artist_name`: от 2 до 100 символов — достаточная длина для названий артистов

2. **Диапазоны значений:**
   - `track_duration`: от 1 до 7200 секунд (2 часа) — разумные ограничения для длительности треков
   - `album_release_date`: от 1900-01-01 до текущей даты + 1 год — валидный диапазон дат релиза
   - `track_order`, `order_position`: больше 0 — положительные значения для порядка треков

3. **Неотрицательные значения:**
   - `track_play_count`, `track_like_count`, `follow_count`: >= 0 — счётчики не могут быть отрицательными
   - `duration_played`: >= 0 — длительность прослушивания неотрицательна

**Внешние ключи (FOREIGN KEY):**

1. **ON DELETE CASCADE:**
   - `users → artists` (через `user_id`): при удалении пользователя удаляются связанные артисты
   - `albums → tracks`: при удалении альбома удаляются все треки альбома
   - `playlists → playlist_tracks`: при удалении плейлиста удаляются связи с треками
   - `users → playlists`: при удалении пользователя удаляются его плейлисты

2. **ON DELETE SET NULL:**
   - `users → tracks` (через `uploaded_by`): при удалении пользователя поле становится NULL, треки сохраняются
   - `users → albums` (через `created_by`): при удалении пользователя поле становится NULL, альбомы сохраняются

3. **ON DELETE RESTRICT:**
   - `roles → users`: при удалении роли операция запрещена, если есть пользователи с этой ролью

**Уникальные ограничения (UNIQUE):**

1. **Поля:**
   - `users.username` — уникальное имя пользователя
   - `artists.artist_name` — уникальное название артиста
   - `genres.genre_name` — уникальное название жанра

2. **Комбинации полей:**
   - `track_genres(track_id, genre_id)` — один трек не может иметь один жанр дважды
   - `playlist_tracks(playlist_id, track_id)` — один трек не может быть в плейлисте дважды
   - `favorites_tracks(user_id, track_id)` — один пользователь не может добавить трек в избранное дважды

**Индексы для оптимизации:**

1. **Индексы по внешним ключам:**
   - `idx_tracks_album`, `idx_albums_artist`, `idx_playlists_user` — ускорение JOIN-запросов

2. **Индексы для сортировки:**
   - `idx_tracks_play_count DESC`, `idx_tracks_like_count DESC` — топ-чарты и популярные треки
   - `idx_playlists_follow_count DESC` — популярные плейлисты

3. **Составные индексы:**
   - `idx_listening_user_date(user_id, listened_at)` — оптимизация запросов истории прослушиваний

### 3.2.3. Диаграмма классов/сервисов

#### 3.2.3.1. Архитектура клиентского приложения

Клиентское приложение построено на основе компонентной архитектуры React с использованием TypeScript.

**Основные компоненты:**

```
App (Root Component)
├── QueryClientProvider (React Query)
├── AppSettingsProvider (Context)
├── PlayerProvider (Context)
├── BrowserRouter (React Router)
│   └── Routes
│       ├── Auth (страница авторизации)
│       └── Layout (основной layout)
│           ├── Header (навигация)
│           ├── Main Content (Outlet)
│           │   ├── Index (главная страница)
│           │   ├── Library (библиотека)
│           │   ├── Playlists (плейлисты)
│           │   ├── Analytics (аналитика)
│           │   ├── Profile (профиль)
│           │   ├── Settings (настройки)
│           │   ├── AdminPanel (админ-панель)
│           │   └── ArtistApplicationsManager (заявки)
│           └── MusicPlayer (медиа-плеер)
└── Toaster (уведомления)
```

**Контексты (Context API):**

1. **PlayerContext:**
   - Управление состоянием медиа-плеера
   - Текущий трек, плейлист, режим перемешивания
   - Методы: `playTrack()`, `nextTrack()`, `previousTrack()`

2. **AppSettingsContext:**
   - Настройки приложения (язык, тема)
   - Сохранение настроек в localStorage

**Хуки (Custom Hooks):**

1. **useRole:**
   - Получение роли пользователя
   - Проверка прав доступа (isAdmin, canManageContent)

2. **useTranslation:**
   - Интернационализация (i18n)
   - Перевод текстов интерфейса

**Сервисы:**

1. **Supabase Client:**
   - Интеграция с Supabase API
   - Аутентификация, работа с БД, Storage

2. **React Query:**
   - Кэширование запросов к API
   - Управление состоянием загрузки и ошибок

#### 3.2.3.2. Архитектура серверной части

Серверная часть реализована на базе Supabase (PostgreSQL + сервисы).

**Сервисы Supabase:**

1. **Supabase Authentication:**
   - Управление пользователями и сессиями
   - JWT токены, хэширование паролей

2. **Supabase Database (PostgreSQL):**
   - Хранение структурированных данных
   - Функции, триггеры, представления
   - Row Level Security (RLS)

3. **Supabase Storage:**
   - Хранение файлов (аудио, изображения)
   - Buckets: `songs`, `covers`, `avatars`

**Функции базы данных:**

1. **toggle_favorite_track()** — добавление/удаление трека из избранного
2. **toggle_favorite_album()** — добавление/удаление альбома из избранного
3. **toggle_favorite_playlist()** — добавление/удаление плейлиста из избранного
4. **approve_artist_application()** — одобрение заявки на статус артиста
5. **reject_artist_application()** — отклонение заявки на статус артиста
6. **ensure_user_exists()** — проверка и создание профиля пользователя

**Триггеры:**

1. **handle_new_user()** — автоматическое создание профиля при регистрации
2. **listening_history_trigger** — обновление счётчика прослушиваний
3. **audit_changes()** — логирование изменений в audit_log
4. **update_updated_at_column** — обновление метки времени `updated_at`

### 3.2.4. Схема пользовательских интерфейсов

#### 3.2.4.1. Навигационная структура

**Основные разделы:**

```
/ (Index)                    # Главная страница
├── /library                 # Библиотека (треки, альбомы, артисты)
├── /playlists               # Плейлисты
│   └── /playlists/:id       # Детали плейлиста
├── /albums/:id              # Детали альбома
├── /artists/:id             # Детали артиста
├── /analytics               # Аналитика и статистика
├── /profile                 # Профиль пользователя
│   ├── /profile/my-tracks    # Мои треки (для артистов)
│   ├── /profile/my-playlists # Мои плейлисты
│   └── /profile/my-favorites # Избранное
├── /settings                # Настройки
├── /admin                   # Админ-панель (только для администраторов)
├── /applications            # Заявки на артиста (для дистрибьюторов)
└── /auth                    # Авторизация и регистрация
```

**Защищённые маршруты:**
- `/admin` — требует роль «администратор»
- `/applications` — требует роль «дистрибьютор» или «модератор»
- Все остальные маршруты (кроме `/auth`) требуют авторизации

#### 3.2.4.2. Макеты страниц

**Layout (общий макет):**
- **Header:** Логотип, навигационное меню, переключатель языка, кнопка выхода
- **Main Content:** Область для контента страниц (Outlet)
- **Music Player:** Фиксированный медиа-плеер внизу страницы
- **Mobile Navigation:** Нижняя панель навигации для мобильных устройств

**Страница авторизации (`/auth`):**
- Форма входа/регистрации
- Переключение между режимами входа и регистрации
- Валидация полей в реальном времени

**Главная страница (`/`):**
- Обзор популярных треков
- Недавние альбомы
- Рекомендации

**Страница библиотеки (`/library`):**
- Фильтры (жанры, артисты, сортировка)
- Список треков с карточками
- Поиск по названию, артисту, альбому

**Страница плейлистов (`/playlists`):**
- Список плейлистов пользователя
- Публичные плейлисты
- Кнопка создания нового плейлиста

**Страница аналитики (`/analytics`):**
- Графики прослушиваний (Recharts)
- Статистика по жанрам
- Популярные треки
- Экспорт данных

#### 3.2.4.3. Состояния интерфейса

**Состояния загрузки:**
- Skeleton loaders для списков и карточек
- Spinner для кнопок при выполнении действий
- Progress bar для загрузки файлов

**Состояния ошибок:**
- Toast-уведомления об ошибках (Sonner)
- Сообщения об ошибках валидации в формах
- Страница 404 для несуществующих маршрутов

**Состояния пустых данных:**
- Сообщения «Нет данных» для пустых списков
- Иллюстрации для пустых состояний

**Адаптивность:**
- Mobile-first подход
- Breakpoints: sm (640px), md (768px), lg (1024px), xl (1280px)
- Мобильная навигация внизу экрана
- Десктопная навигация в header

### 3.2.5. Схема архитектуры

#### 3.2.5.1. Общая архитектура системы

```
┌─────────────────────────────────────────────────────────────┐
│                    КЛИЕНТСКОЕ ПРИЛОЖЕНИЕ                     │
│  React 18 + TypeScript + Vite + Tailwind CSS + Shadcn UI    │
└─────────────────────────────────────────────────────────────┘
                            │
                            │ HTTPS / REST API
                            │ JWT Authentication
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                    SUPABASE PLATFORM                        │
│  ┌──────────────────┐  ┌──────────────────┐                │
│  │  Authentication  │  │    PostgreSQL    │                │
│  │  - JWT Tokens    │  │    Database     │                │
│  │  - bcrypt Hash   │  │    - Tables     │                │
│  │  - Sessions      │  │    - Functions  │                │
│  └──────────────────┘  │    - Triggers   │                │
│                        │    - Views      │                │
│                        │    - RLS        │                │
│                        └──────────────────┘                │
│  ┌──────────────────┐                                      │
│  │     Storage      │                                      │
│  │  - songs bucket │                                      │
│  │  - covers bucket│                                      │
│  │  - avatars bucket│                                     │
│  └──────────────────┘                                      │
└─────────────────────────────────────────────────────────────┘
```

#### 3.2.5.2. Поток данных

**Регистрация пользователя:**
```
Client → Supabase Auth → auth.users → Trigger → public.users
```

**Загрузка трека:**
```
Client → Supabase Storage (upload file) → Get URL → 
Client → Supabase Database (insert track) → Trigger (audit_log)
```

**Воспроизведение трека:**
```
Client → Supabase Database (get track metadata) → 
Client → Supabase Storage (get audio URL) → 
Client → Media Player (play audio) → 
Client → Supabase Database (insert listening_history) → 
Trigger → Update track_play_count
```

**Запрос данных:**
```
Client → React Query → Supabase Client → PostgreSQL → 
RLS Policies → Return Data → React Query Cache → Client
```

#### 3.2.5.3. Компоненты безопасности

1. **Аутентификация:**
   - Supabase Authentication с JWT токенами
   - Хэширование паролей через bcrypt
   - HttpOnly cookies в production

2. **Авторизация:**
   - Row Level Security (RLS) на уровне БД
   - Ролевая модель доступа (RBAC)
   - ProtectedRoute на уровне клиента

3. **Защита данных:**
   - Параметризованные запросы (защита от SQL-инъекций)
   - Автоматическое экранирование в React (защита от XSS)
   - Валидация данных на клиенте и сервере

### 3.2.6. Схема тестирования

#### 3.2.6.1. Пирамида тестов

```
                    ┌─────────────┐
                    │   E2E Tests │  (10%)
                    │  Playwright │
                    └─────────────┘
                           │
            ┌──────────────┼──────────────┐
            │                              │
    ┌───────────────┐            ┌───────────────┐
    │ Integration   │            │  Unit Tests  │
    │    Tests      │  (30%)     │              │  (60%)
    │  React Query  │            │  Components  │
    │  Supabase API │            │  Functions    │
    └───────────────┘            └───────────────┘
```

**Уровни тестирования:**

1. **Unit Tests (60%):**
   - Тестирование отдельных компонентов React
   - Тестирование функций и утилит
   - Тестирование хуков (useRole, useTranslation)
   - Инструменты: Vitest, React Testing Library

2. **Integration Tests (30%):**
   - Тестирование взаимодействия компонентов
   - Тестирование запросов к Supabase API
   - Тестирование React Query кэширования
   - Инструменты: Vitest, React Testing Library, MSW (Mock Service Worker)

3. **E2E Tests (10%):**
   - Тестирование полных пользовательских сценариев
   - Тестирование навигации и взаимодействия
   - Инструменты: Playwright, Cypress

#### 3.2.6.2. Инструменты тестирования

**Unit и Integration тесты:**
- **Vitest** — быстрый тестовый фреймворк, совместимый с Vite
- **React Testing Library** — тестирование React компонентов
- **MSW (Mock Service Worker)** — мокирование HTTP-запросов к Supabase API
- **@testing-library/user-event** — симуляция пользовательских действий

**E2E тесты:**
- **Playwright** — автоматизация браузера для E2E тестов
- **Cypress** (альтернатива) — E2E тестирование с удобным интерфейсом

**Тестирование безопасности:**
- **Ручное тестирование** RLS политик через Supabase Dashboard
- **SQL-инъекции** — проверка параметризованных запросов
- **XSS** — проверка экранирования данных в React

#### 3.2.6.3. Метрики качества

**Покрытие кода:**
- Целевое покрытие: 70%+ для критичных компонентов
- Инструмент: Vitest coverage

**Производительность:**
- Время загрузки страниц: < 2 секунд
- Время отклика API: < 500 мс
- Инструмент: Lighthouse, Chrome DevTools

**Доступность (Accessibility):**
- Соответствие WCAG 2.1 Level AA
- Инструмент: axe DevTools, Lighthouse

**Безопасность:**
- Отсутствие уязвимостей в зависимостях
- Инструмент: npm audit, Snyk

---

## 3.3. Описание мер защиты

В проекте Imperial Tunes реализована многоуровневая система защиты данных, обеспечивающая безопасность на всех уровнях архитектуры:

- **Уровень аутентификации** — Supabase Authentication с хэшированием паролей.
- **Уровень базы данных** — Row Level Security (RLS) и политики безопасности.
- **Уровень приложения** — защита маршрутов и валидация данных.
- **Уровень сети** — HTTP заголовки безопасности и CORS.
- **Уровень файлов** — защита Storage buckets с RLS.

### 3.3.1. Аутентификация пользователей

Используется встроенная система аутентификации Supabase, которая обеспечивает:

#### Хэширование паролей

Supabase автоматически преобразует пароль пользователя в хэшированный вид перед сохранением. Это исключает хранение паролей в открытом виде и повышает безопасность системы.

**Основные особенности:**

- Пароль никогда не сохраняется как обычный текст.
- При хэшировании используется алгоритм bcrypt с автоматическим добавлением соли (salt).
- Хэширование выполняется непосредственно на стороне сервера Supabase.
- Минимально допустимая длина пароля — 6 символов.
- Ключи и алгоритмы шифрования обеспечиваются платформой и не требуют дополнительной настройки в проекте.

**Реализация в коде:**
```typescript
// Регистрация пользователя (src/pages/Auth.tsx, строки 81-94)
const { data: authData, error: signUpError } = await supabase.auth.signUp({
  email,
  password, // Пароль автоматически хэшируется Supabase через bcrypt
  options: {
    emailRedirectTo: `${window.location.origin}/`,
    data: {
      username: username.trim(),
      first_name: firstName.trim() || null,
      last_name: lastName.trim() || null,
    },
  },
});
```

#### Хранение данных пользователей

- Данные аутентификации хранятся во внутренней системной таблице `auth.users`.
- Таблица относится к служебной схеме Supabase и не доступна напрямую для изменения со стороны клиента.
- Доступ к полям пароля отсутствует даже у администратора — сохраняются только хэшированные значения.
- Все операции производятся через Supabase API и механизмы авторизации.

#### Безопасность доступа

- Прямой доступ к таблице `auth.users` закрыт политиками безопасности (RLS).
- Внешние запросы выполняются только через методы `supabase.auth.*`.
- Исключается возможность получения или восстановления исходного пароля.

#### Управление сессиями

Для управления авторизацией и сохранением состояния входа пользователя в системе используется механизм JWT-токенов (JSON Web Token). Данный подход позволяет обеспечивать безопасную и надёжную передачу данных о пользователе между клиентом и сервером.

**Основные особенности:**

- После успешной аутентификации Supabase предоставляет пользователю JWT-токен.
- В токене содержится основная информация о пользователе, включая уникальный идентификатор и назначенную роль.
- Токен имеет ограниченный срок действия и автоматически обновляется, что предотвращает внезапный выход пользователя из системы.
- В режиме разработки токен хранится в localStorage браузера.
- В production-режиме Supabase использует HttpOnly cookies, что обеспечивает дополнительную защиту от атак типа XSS.

**Преимущества использования JWT:**

- Нет необходимости хранить пароль или чувствительные данные на стороне клиента.
- Обеспечивается упрощённая проверка подлинности пользователя при каждом запросе.
- Совместимость с REST и WebSocket API.

**Реализация в коде:**
```typescript
// Создание клиента Supabase с автоматическим управлением токенами (src/integrations/supabase/client.ts)
import { createClient } from '@supabase/supabase-js';

export const supabase = createClient(
  import.meta.env.VITE_SUPABASE_URL,
  import.meta.env.VITE_SUPABASE_ANON_KEY
);

// Автоматическая проверка сессии при каждом запросе
const { data: { session } } = await supabase.auth.getSession();
```

### 3.3.2. Авторизация и контроль доступа

#### Row Level Security (RLS)

В проекте реализована система Row Level Security (RLS) для всех таблиц базы данных, обеспечивающая контроль доступа на уровне строк через политики безопасности.

**Включение RLS:**
```sql
-- Включение RLS для всех таблиц (supabase/migrations/20250201000000_complete_database_schema.sql)
ALTER TABLE public.roles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.artists ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.genres ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.albums ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.tracks ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.playlists ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.track_genres ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.playlist_tracks ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.listening_history ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.audit_log ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.favorites_tracks ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.favorites_albums ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.favorites_playlists ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.artist_applications ENABLE ROW LEVEL SECURITY;
```

**Пример политики безопасности:**
```sql
-- Политика: Пользователи могут просматривать только свой профиль
CREATE POLICY "Users can view own profile" ON public.users
FOR SELECT TO authenticated
USING (auth.uid() = id);

-- Политика: Пользователи могут обновлять только свой профиль
CREATE POLICY "Users can update own profile" ON public.users
FOR UPDATE TO authenticated
USING (auth.uid() = id)
WITH CHECK (auth.uid() = id);
```

#### Ролевая модель доступа (RBAC)

В проекте реализована ролевая модель доступа с пятью уровнями прав:

- **Слушатель** — базовый пользователь, может прослушивать музыку, создавать плейлисты, добавлять треки в избранное.
- **Артист** — может загружать треки и альбомы, управлять своим контентом, просматривать статистику.
- **Дистрибьютор** — может обрабатывать заявки на статус артиста, управлять контентом.
- **Модератор** — может модерировать контент, обрабатывать заявки.
- **Администратор** — имеет полный доступ к управлению системой, пользователями и контентом.

**Реализация защиты маршрутов:**
```typescript
// Защита административных маршрутов (src/App.tsx, строки 52-67)
<Route 
  path="/admin" 
  element={
    <ProtectedRoute requireAdmin>
      <AdminPanel />
    </ProtectedRoute>
  } 
/>
<Route 
  path="/applications" 
  element={
    <ProtectedRoute requireContentManagement>
      <ArtistApplicationsManager />
    </ProtectedRoute>
  } 
/>
```

### 3.3.3. Защита базы данных

#### Параметризованные запросы

Все SQL-запросы выполняются через Supabase Client API, который автоматически экранирует параметры, предотвращая SQL-инъекции.

**Пример безопасного запроса:**
```typescript
// Безопасный параметризованный запрос (src/pages/Library.tsx, строки 99-128)
const { data, error } = await supabase
  .from("tracks")
  .select(`
    id,
    track_title,
    track_duration,
    track_play_count,
    track_like_count,
    track_audio_url,
    uploaded_by,
    created_at,
    album:albums(
      id,
      album_title,
      album_cover_url,
      artist:artists(
        id,
        artist_name
      )
    ),
    genres:track_genres(
      id,
      genre:genres(
        id,
        genre_name
      )
    )
  `)
  .eq("is_public", true)  // Параметры автоматически экранируются
  .order(sortBy, { ascending: sortOrder === "asc" });
```

#### Валидация данных на уровне БД

Использование CHECK ограничений для валидации данных:
```sql
-- Проверка длительности трека и других ограничений (supabase/migrations/20250201000000_complete_database_schema.sql, строки 239-249)
CREATE TABLE public.tracks (
    track_duration INTEGER NOT NULL,
    track_play_count INTEGER NOT NULL DEFAULT 0,
    track_like_count INTEGER NOT NULL DEFAULT 0,
    track_order INTEGER NOT NULL DEFAULT 1,
    track_title TEXT NOT NULL,
    CHECK (
        track_duration > 0
        AND track_duration <= 7200
    ),
    CHECK (track_play_count >= 0),
    CHECK (track_like_count >= 0),
    CHECK (track_order > 0),
    CHECK (
        LENGTH(track_title) >= 1
        AND LENGTH(track_title) <= 100
    )
);
```

### 3.3.4. Защита файлов и Storage

#### Row Level Security для Storage

В проекте реализованы RLS политики для контроля доступа к файлам в Supabase Storage buckets:

- **Bucket `songs`** — аудиофайлы доступны только владельцам (артистам) и публично для прослушивания.
- **Bucket `covers`** — обложки альбомов доступны публично для просмотра.
- **Bucket `avatars`** — аватары пользователей доступны только владельцам и публично для просмотра.

**Пример политики Storage:**
```sql
-- Политика для загрузки аудиофайлов (supabase/migrations/20250201000000_complete_database_schema.sql)
CREATE POLICY "Artists can upload own songs" ON storage.objects
FOR INSERT TO authenticated
WITH CHECK (
  bucket_id = 'songs' 
  AND auth.uid()::text = (storage.foldername(name))[1]
);
```

#### Валидация файлов

Валидация форматов и размеров файлов перед загрузкой:
```typescript
// Валидация формата и размера файла (src/components/UploadTrackDialog.tsx, строки 217-229)
const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
  const file = e.target.files?.[0];
  if (file) {
    // Проверяем формат файла
    const extension = file.name.split('.').pop()?.toLowerCase();
    if (!audioFormats.some(format => format.value === extension)) {
      toast.error(t('upload.error.fileFormat'));
      return;
    }

    // Проверяем размер файла (50MB)
    if (file.size > 50 * 1024 * 1024) {
      toast.error(t('upload.error.fileSize'));
      return;
    }
  }
};
```

### 3.3.5. Аудит и мониторинг

#### Система аудита изменений

В проекте реализована система аудита для логирования всех критических операций через триггер `audit_changes`:

```sql
-- Функция аудита изменений (supabase/migrations/20250201000000_complete_database_schema.sql)
CREATE OR REPLACE FUNCTION public.audit_changes()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.audit_log (
    table_name,
    operation,
    user_id,
    old_data,
    new_data,
    changed_at
  ) VALUES (
    TG_TABLE_NAME,
    TG_OP,
    auth.uid(),
    row_to_json(OLD),
    row_to_json(NEW),
    now()
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Применение триггера к таблице tracks
CREATE TRIGGER audit_tracks_trigger
AFTER INSERT OR UPDATE OR DELETE ON public.tracks
FOR EACH ROW EXECUTE FUNCTION public.audit_changes();
```

**Таблица аудит-лога:**
```sql
CREATE TABLE public.audit_log (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    table_name TEXT NOT NULL,
    operation TEXT NOT NULL CHECK (operation IN ('INSERT', 'UPDATE', 'DELETE')),
    user_id UUID REFERENCES public.users(id) ON DELETE SET NULL,
    old_data JSONB,
    new_data JSONB,
    changed_at TIMESTAMPTZ NOT NULL DEFAULT now()
);
```

---

## 3.4. Описание бэкапов и процедуры восстановления

Проект Imperial Tunes использует многоуровневую систему резервного копирования для защиты данных на всех уровнях системы. Реализованы автоматизированные скрипты для создания бэкапов базы данных и файлов Storage, а также процедуры восстановления из бэкапов.

### 3.4.1. Типы бэкапов

В проекте реализованы следующие типы резервного копирования:

**1. Бэкап базы данных:**
- **Метод:** SQL дампы через `pg_dump` или экспорт данных через Supabase API в JSON
- **Частота:** Ежедневно (рекомендуется) или перед важными изменениями
- **Хранение:** Локально в директории `backups/` и опционально в облачном хранилище
- **Критичность:** Критический

**2. Бэкап Storage файлов:**
- **Аудио файлы (songs):** Копирование всех файлов из bucket `songs` (mp3, wav, flac, ogg, m4a)
- **Изображения (covers):** Копирование обложек альбомов из bucket `covers` (jpeg, png, webp)
- **Аватары (avatars):** Копирование аватаров пользователей из bucket `avatars` (jpeg, png, webp)
- **Частота:** Еженедельно или при необходимости
- **Хранение:** Локально и опционально в облачном хранилище
- **Критичность:** Критический (songs), Высокий (covers, avatars)

**3. Бэкап миграций:**
- **Метод:** Git репозиторий
- **Частота:** При каждом изменении схемы БД
- **Хранение:** Git (GitHub/GitLab)
- **Критичность:** Высокий

**4. Бэкап конфигурации:**
- **Метод:** Архивирование файлов конфигурации
- **Файлы:** `.env.local`, `nginx.conf`, `docker-compose.yml`, `vite.config.ts`
- **Частота:** При изменении конфигурации
- **Хранение:** Зашифрованное хранилище
- **Критичность:** Средний

### 3.4.2. Процедура создания бэкапов

#### 3.4.2.1. Ручной бэкап через скрипт

**Основной скрипт:** `scripts/backup-supabase.js`

**Использование:**

**Windows:**
```batch
scripts\backup-supabase-windows.bat
```

**Linux/Mac:**
```bash
# Загрузить переменные окружения
source .env.backup

# Создать бэкап
node scripts/backup-supabase.js

# Или через полный скрипт (с загрузкой в облако)
bash scripts/full-backup-supabase.sh
```

**Требуемые переменные окружения:**
- `SUPABASE_URL` — URL проекта Supabase
- `SUPABASE_SERVICE_ROLE_KEY` — Service Role Key (для доступа к Storage)
- `SUPABASE_DB_URL` — Connection string для PostgreSQL (опционально, для прямого доступа к БД)

**Процесс выполнения скрипта:**

1. **Проверка переменных окружения:**
   - Проверка наличия `SUPABASE_URL` и `SUPABASE_SERVICE_ROLE_KEY`
   - Проверка наличия `SUPABASE_DB_URL` (опционально)

2. **Создание бэкапа базы данных:**
   
   **Метод 1 (если установлен SUPABASE_DB_URL):**
   - Использование `pg_dump` для создания полного SQL дампа
   - Включает схему и данные
   - Автоматическое сжатие (gzip) на Linux/Mac
   - Параметры: `--format=plain`, `--no-owner`, `--no-privileges`, `--clean`, `--if-exists`
   
   **Метод 2 (через Supabase API):**
   - Экспорт всех таблиц в JSON через Supabase API
   - Экспортирует только данные (схема не включается)
   - Используется автоматически, если `pg_dump` недоступен

3. **Скачивание файлов из Storage:**
   - Рекурсивное скачивание всех файлов из bucket `songs`
   - Скачивание файлов из bucket `covers`
   - Скачивание файлов из bucket `avatars`
   - Fallback на публичные URL при ошибках доступа

4. **Создание информации о бэкапе:**
   - Создание файла `backup_info.txt` с метаданными (дата, размер, количество файлов)
   - Создание JSON файла с детальной информацией
   - Подсчёт размеров и количества файлов

5. **Создание архива (опционально):**
   - Создание tar.gz архива всего бэкапа
   - Автоматически на Linux/Mac
   - Пропускается на Windows (gzip может быть недоступен)

**Структура создаваемого бэкапа:**
```
backups/supabase_backup_YYYYMMDD_HHMMSS/
├── database/
│   ├── database_backup_YYYYMMDD_HHMMSS.sql (или .sql.gz)
│   └── database_data_YYYYMMDD_HHMMSS.json (если через API)
├── storage/
│   ├── songs/     (все аудио файлы)
│   ├── covers/    (обложки альбомов)
│   └── avatars/   (аватары пользователей)
├── backup_info.txt
└── backup_info.json
```

**Что включается в бэкап базы данных:**
- Все таблицы схемы `public`
- Все данные таблиц
- Все функции (SECURITY DEFINER)
- Все триггеры
- Все индексы
- Все представления (views)
- Все типы данных (ENUM)
- Все RLS политики
- Все внешние ключи и ограничения

**Что не включается:**
- Таблица `auth.users` (Supabase Auth, управляется отдельно)
- Временные таблицы
- Информация о владельцах объектов (из-за `--no-owner`)
- Права доступа (из-за `--no-privileges`)

#### 3.4.2.2. Автоматизация бэкапов

**Cron задача для Linux/Mac:**
```bash
# Ежедневно в 2:00 ночи
0 2 * * * cd /path/to/project && source .env.backup && export $(cat .env.backup | xargs) && node scripts/backup-supabase.js >> /var/log/supabase_backup.log 2>&1
```

**Windows Task Scheduler:**
1. Создать bat файл `auto-backup.bat`:
```batch
@echo off
cd /d C:\path\to\project
call scripts\backup-supabase-windows.bat
```
2. Настроить Task Scheduler для ежедневного запуска в 2:00

**Полный бэкап с загрузкой в облако:**
```bash
# Скрипт: scripts/full-backup-supabase.sh
bash scripts/full-backup-supabase.sh
```

Выполняет:
1. Создание бэкапа БД и Storage
2. Создание архива
3. Загрузку в облачное хранилище (AWS S3 или rclone), если настроено

### 3.4.3. Процедура восстановления

#### 3.4.3.1. Восстановление через скрипт

**Скрипт:** `scripts/restore-supabase.js`

**Использование:**
```bash
# Загрузить переменные окружения
source .env.backup

# Восстановление из бэкапа (указать директорию бэкапа)
node scripts/restore-supabase.js ./backups/supabase_backup_YYYYMMDD_HHMMSS
```

**Требования:**
- Установлены переменные окружения: `SUPABASE_URL`, `SUPABASE_SERVICE_ROLE_KEY`
- Наличие директории бэкапа с файлами базы данных и Storage

**Процесс выполнения:**

1. **Проверка аргументов:**
   - Проверка наличия директории бэкапа
   - Проверка наличия файлов базы данных и Storage

2. **Проверка переменных окружения:**
   - Проверка `SUPABASE_URL` и `SUPABASE_SERVICE_ROLE_KEY`
   - Проверка `SUPABASE_DB_URL` (если используется SQL дамп)

3. **Подтверждение пользователя:**
   - Запрос подтверждения перед восстановлением
   - Предупреждение о замене текущих данных

4. **Восстановление базы данных:**
   
   **Если есть SQL дамп:**
   - Использование `psql` для восстановления из SQL файла
   - Поддержка сжатых файлов (gunzip)
   - Или использование Supabase API для прямого восстановления
   
   **Если есть JSON данные:**
   - Восстановление через Supabase API
   - Загрузка данных в таблицы по порядку батчами по 1000 записей

5. **Восстановление Storage файлов:**
   - Загрузка файлов в bucket `songs`
   - Загрузка файлов в bucket `covers`
   - Загрузка файлов в bucket `avatars`
   - Сохранение структуры директорий (user_id/path)
   - Использование upsert для перезаписи существующих файлов

6. **Проверка восстановления:**
   - Проверка количества записей в таблицах
   - Проверка наличия основных таблиц
   - Проверка загруженных файлов в Storage

#### 3.4.3.2. Ручное восстановление через psql

**Для сжатого файла:**
```bash
gunzip -c backups/supabase_backup_YYYYMMDD_HHMMSS/database/*.sql.gz | \
  psql -h db.xxxxx.supabase.co -U postgres -d postgres
```

**Для несжатого файла:**
```bash
psql -h db.xxxxx.supabase.co -U postgres -d postgres < \
  backups/supabase_backup_YYYYMMDD_HHMMSS/database/*.sql
```

#### 3.4.3.3. Восстановление через миграции

**Метод:** Применение всех миграций по порядку

**Процедура:**
```bash
# Применение всех миграций через Supabase CLI
supabase db reset

# Или вручную через psql
for migration in supabase/migrations/*.sql; do
  echo "Applying: $migration"
  psql -h localhost -U postgres -d imperial_tunes -f "$migration"
done
```

### 3.4.4. Хранение и ротация бэкапов

**Локальное хранилище:**
- Структура: `backups/supabase_backup_YYYYMMDD_HHMMSS/`
- Рекомендуется сохранять последние 7-30 бэкапов (в зависимости от размера)
- Можно настроить автоматическую ротацию через cron задачи или скрипты очистки

**Облачное хранилище (опционально):**
- Рекомендуемые сервисы: AWS S3, Google Cloud Storage, Azure Blob Storage, Backblaze B2
- Автоматическая загрузка через скрипт `scripts/upload-to-cloud.js`
- Настройка lifecycle политики для автоматического удаления старых бэкапов

**Политика ротации:**
- **Ежедневный бэкап:** Хранение 7 дней, автоматическое удаление
- **Еженедельный бэкап:** Хранение 4 недели, автоматическое удаление через 28 дней
- **Ежемесячный бэкап:** Хранение 12 месяцев, автоматическое удаление через 1 год
- **Годовой бэкап:** Хранение 5 лет, ручное удаление

### 3.4.5. Проверка целостности бэкапов

**Автоматическая проверка:**
- Скрипт `restore-supabase.js` проверяет наличие всех необходимых файлов перед восстановлением
- Проверка структуры директории бэкапа
- Проверка наличия файлов базы данных и Storage

**Ручная проверка:**
```bash
# Проверить наличие файлов бэкапа
ls -la backups/supabase_backup_YYYYMMDD_HHMMSS/

# Проверить размер файлов базы данных
ls -lh backups/supabase_backup_YYYYMMDD_HHMMSS/database/

# Проверить количество файлов в Storage
find backups/supabase_backup_YYYYMMDD_HHMMSS/storage -type f | wc -l

# Проверить содержимое backup_info.txt
cat backups/supabase_backup_YYYYMMDD_HHMMSS/backup_info.txt
```

**Тестовое восстановление:**
Рекомендуется создать тестовый проект Supabase и восстановить бэкап туда перед восстановлением в production:
1. Создать новый проект в Supabase Dashboard (тестовый)
2. Скопировать `.env.backup` в `.env.backup.test` и обновить URL на тестовый проект
3. Выполнить восстановление в тестовый проект
4. Проверить данные в тестовом проекте
5. Если всё корректно, выполнить восстановление в production проект

### 3.4.6. Рекомендации по бэкапам

**Частота создания бэкапов:**
- **Production:** Каждые 6 часов или ежедневно
- **Development:** Ежедневно или перед важными изменениями
- **Перед миграциями:** Обязательно создать бэкап

**Правило 3-2-1:**
- **3** копии данных (оригинал + 2 бэкапа)
- **2** разных типа носителей (локальный диск + облако)
- **1** копия в удалённом хранилище

**Тестирование восстановления:**
- Ежемесячно тестировать восстановление из бэкапа
- Проверять целостность данных после восстановления
- Документировать результаты тестирования

**Мониторинг бэкапов:**
- Успешность создания бэкапов
- Размер бэкапов (аномальные изменения)
- Время создания бэкапов
- Доступность хранилища бэкапов

---
