# МЕРЫ ЗАЩИТЫ ДАННЫХ
## Проект: Imperial Tunes

**Версия документа:** 1.0  
**Дата создания:** 09.11.2025  
**База данных:** PostgreSQL (Supabase)

---

## ОГЛАВЛЕНИЕ

1. [Общая информация](#общая-информация)
2. [Аутентификация пользователей](#аутентификация-пользователей)
3. [Авторизация и контроль доступа](#авторизация-и-контроль-доступа)
4. [Защита базы данных](#защита-базы-данных)
5. [Защита файлов и Storage](#защита-файлов-и-storage)
6. [Защита на уровне приложения](#защита-на-уровне-приложения)
7. [Сетевая безопасность](#сетевая-безопасность)
8. [Валидация и санитизация данных](#валидация-и-санитизация-данных)
9. [Аудит и мониторинг](#аудит-и-мониторинг)
10. [Защита от уязвимостей](#защита-от-уязвимостей)

---

## ОБЩАЯ ИНФОРМАЦИЯ

В проекте Imperial Tunes реализована многоуровневая система защиты данных, обеспечивающая безопасность на всех уровнях архитектуры:

- **Уровень аутентификации** - Supabase Authentication с хэшированием паролей
- **Уровень базы данных** - Row Level Security (RLS) и политики безопасности
- **Уровень приложения** - защита маршрутов и валидация данных
- **Уровень сети** - HTTP заголовки безопасности и CORS
- **Уровень файлов** - защита Storage buckets с RLS

---

## АУТЕНТИФИКАЦИЯ ПОЛЬЗОВАТЕЛЕЙ

### 1. Supabase Authentication

Используется встроенная система аутентификации Supabase, которая обеспечивает:

#### 1.1. Хэширование паролей

**Метод:** Автоматическое хэширование через bcrypt

**Описание:**
- Пароли никогда не хранятся в открытом виде
- Используется алгоритм bcrypt с автоматическим добавлением соли (salt)
- Хэширование выполняется на стороне Supabase перед сохранением в БД
- Минимальная длина пароля: 6 символов

**Код:**
```typescript:src/pages/Auth.tsx
// Пароль автоматически хэшируется Supabase
const { data: authData, error: signUpError } = await supabase.auth.signUp({
  email,
  password, // Хэшируется автоматически
  options: {
    emailRedirectTo: `${window.location.origin}/`,
    data: {
      username: username.trim(),
      first_name: firstName.trim() || null,
      last_name: lastName.trim() || null,
    },
  },
});
```

**Хранение:**
- Пароли хранятся в таблице `auth.users` (внутренняя схема Supabase)
- Доступ к таблице `auth.users` ограничен только для системных операций
- Пароли недоступны через API или SQL запросы

#### 1.2. Управление сессиями

**Метод:** JWT токены (JSON Web Tokens)

**Описание:**
- После успешной аутентификации пользователь получает JWT токен
- Токен содержит информацию о пользователе и его роли
- Токен автоматически обновляется при истечении срока действия
- Токен хранится в localStorage браузера (защищён от XSS через HttpOnly cookies в production)

**Использование:**
```typescript:src/integrations/supabase/client.ts
// Создание клиента Supabase с автоматическим управлением токенами
export const supabase = createClient(
  import.meta.env.VITE_SUPABASE_URL,
  import.meta.env.VITE_SUPABASE_ANON_KEY
);

// Автоматическая проверка сессии при каждом запросе
const { data: { session } } = await supabase.auth.getSession();
```

#### 1.3. Проверка аутентификации

**Метод:** Защита маршрутов на клиенте

**Реализация:**
```typescript:src/components/ProtectedRoute.tsx
const ProtectedRoute = ({ 
  children, 
  requireAdmin = false, 
  requireContentManagement = false 
}: ProtectedRouteProps) => {
  const { role, loading, isAdmin, canManageContent } = useRole();

  // Проверка наличия аутентификации
  if (!role) {
    return <Navigate to="/auth" replace />;
  }

  // Проверка прав администратора
  if (requireAdmin && !isAdmin) {
    return <Navigate to="/" replace />;
  }

  // Проверка прав управления контентом
  if (requireContentManagement && !canManageContent) {
    return <Navigate to="/" replace />;
  }

  return <>{children}</>;
};
```

**Использование:**
```typescript:src/App.tsx
<Route 
  path="/admin" 
  element={
    <ProtectedRoute requireAdmin>
      <AdminPanel />
    </ProtectedRoute>
  } 
/>
```

---

## АВТОРИЗАЦИЯ И КОНТРОЛЬ ДОСТУПА

### 2. Row Level Security (RLS)

RLS включена для всех таблиц базы данных, обеспечивая контроль доступа на уровне строк.

#### 2.1. Включение RLS для всех таблиц

**Реализация:**
```sql:supabase/migrations/20250201000000_complete_database_schema.sql
-- Включение RLS для всех таблиц
ALTER TABLE public.roles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.artists ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.genres ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.albums ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.tracks ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.playlists ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.track_genres ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.playlist_tracks ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.listening_history ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.audit_log ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.favorites_tracks ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.favorites_albums ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.favorites_playlists ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.artist_applications ENABLE ROW LEVEL SECURITY;
```

#### 2.2. Политики безопасности для пользователей

**Политика: Просмотр собственного профиля**
```sql
CREATE POLICY "Users can view own profile" ON public.users FOR
SELECT TO authenticated USING (auth.uid() = id);
```

**Политика: Обновление собственного профиля**
```sql
CREATE POLICY "Users can update own profile" ON public.users FOR
UPDATE TO authenticated USING (auth.uid() = id)
WITH CHECK (auth.uid() = id);
```

**Политика: Просмотр публичной информации пользователей**
```sql
CREATE POLICY "Users can view public user info" ON public.users FOR
SELECT TO authenticated USING (TRUE);
```

**Политика: Администраторы могут обновлять любые профили**
```sql
CREATE POLICY "Admins can update any user" ON public.users FOR
UPDATE TO authenticated USING (
    EXISTS (
        SELECT 1
        FROM public.users u
            JOIN public.roles r ON u.role_id = r.id
        WHERE
            u.id = auth.uid()
            AND r.role_name = 'администратор'
    )
);
```

#### 2.3. Политики безопасности для треков

**Политика: Просмотр публичных треков**
```sql
CREATE POLICY "Anyone can view public tracks" ON public.tracks FOR
SELECT TO authenticated USING (is_public = TRUE);
```

**Политика: Просмотр собственных треков**
```sql
CREATE POLICY "Users can view own tracks" ON public.tracks FOR
SELECT TO authenticated USING (uploaded_by = auth.uid());
```

**Политика: Создание треков (только для артистов с одобренной анкетой)**
```sql
CREATE POLICY "Artists can insert tracks" ON public.tracks FOR
INSERT TO authenticated
WITH CHECK (
    uploaded_by = auth.uid()
    AND (
        -- Дистрибьюторы и администраторы могут создавать треки для любых артистов
        EXISTS (
            SELECT 1
            FROM public.users u
                JOIN public.roles r ON u.role_id = r.id
            WHERE
                u.id = auth.uid()
                AND (
                    r.role_name = 'дистрибьютор'
                    OR r.role_name = 'администратор'
                )
        )
        OR
        -- Артисты могут создавать треки только для альбомов текущего активного артиста
        (
            EXISTS (
                SELECT 1
                FROM public.users u
                    JOIN public.roles r ON u.role_id = r.id
                WHERE
                    u.id = auth.uid()
                    AND r.role_name = 'артист'
            )
            AND EXISTS (
                SELECT 1
                FROM public.albums a
                    JOIN public.artists ar ON a.artist_id = ar.id
                WHERE
                    a.id = tracks.album_id
                    AND ar.user_id = auth.uid()
                    AND EXISTS (
                        SELECT 1
                        FROM public.artist_applications aa
                        WHERE
                            aa.user_id = auth.uid()
                            AND aa.status = 'approved'
                            AND aa.artist_name = ar.artist_name
                    )
            )
        )
    )
);
```

#### 2.4. Политики безопасности для плейлистов

**Политика: Просмотр собственных плейлистов**
```sql
CREATE POLICY "Users can view own playlists" ON public.playlists FOR
SELECT TO authenticated USING (user_id = auth.uid());
```

**Политика: Просмотр публичных плейлистов**
```sql
CREATE POLICY "Anyone can view public playlists" ON public.playlists FOR
SELECT TO authenticated USING (is_public = TRUE);
```

**Политика: Создание плейлистов**
```sql
CREATE POLICY "Users can create playlists" ON public.playlists FOR
INSERT TO authenticated
WITH CHECK (user_id = auth.uid());
```

**Политика: Управление треками в собственных плейлистах**
```sql
CREATE POLICY "Users can manage tracks in own playlists" ON public.playlist_tracks 
FOR ALL TO authenticated USING (
    EXISTS (
        SELECT 1
        FROM public.playlists
        WHERE
            id = playlist_id
            AND user_id = auth.uid()
    )
);
```

#### 2.5. Ролевая модель доступа (RBAC)

**Роли в системе:**
1. **Слушатель** - базовые права: просмотр музыки, создание плейлистов
2. **Артист** - права слушателя + загрузка треков и альбомов (только для одобренного профиля)
3. **Дистрибьютор** - права артиста + одобрение заявок артистов, создание контента для любых артистов
4. **Администратор** - полный доступ ко всем функциям системы
5. **Модератор** - права слушателя + модерация контента

**Проверка ролей:**
```typescript:src/hooks/useRole.ts
export const useRole = () => {
  const [role, setRole] = useState<string | null>(null);
  
  // Получение роли пользователя из БД
  const { data: userData, error } = await supabase
    .from("users")
    .select(`role:roles(role_name)`)
    .eq("id", user.id)
    .single();

  // Вычисляемые свойства для проверки ролей
  const isAdmin = role === "администратор";
  const isDistributor = role === "дистрибьютор";
  const isArtist = role === "артист";
  const isListener = role === "слушатель";
  const canManageContent = isAdmin || isDistributor || isArtist;
  const canAccessAdmin = isAdmin;

  return {
    role,
    isAdmin,
    isDistributor,
    isArtist,
    isListener,
    canManageContent,
    canAccessAdmin
  };
};
```

---

## ЗАЩИТА БАЗЫ ДАННЫХ

### 3. Защита от SQL инъекций

#### 3.1. Параметризованные запросы

**Метод:** Использование Supabase Client API

**Описание:**
- Все запросы к БД выполняются через Supabase Client
- Supabase автоматически экранирует все параметры запросов
- Прямые SQL запросы не используются в клиентском коде

**Примеры безопасных запросов:**
```typescript
// Безопасный SELECT запрос
const { data, error } = await supabase
  .from("tracks")
  .select("*")
  .eq("id", trackId) // Параметр автоматически экранируется
  .single();

// Безопасный INSERT запрос
const { data, error } = await supabase
  .from("playlists")
  .insert({
    playlist_title: title, // Параметры автоматически экранируются
    user_id: userId,
    is_public: false
  });

// Безопасный UPDATE запрос
const { error } = await supabase
  .from("users")
  .update({ username: newUsername })
  .eq("id", userId); // Параметры автоматически экранируются
```

#### 3.2. Функции с SECURITY DEFINER

**Метод:** Использование функций PostgreSQL с SECURITY DEFINER

**Описание:**
- Критические функции выполняются с правами создателя функции
- Функции проверяют права доступа перед выполнением операций
- Используется `auth.uid()` для получения идентификатора текущего пользователя

**Пример:**
```sql:supabase/migrations/20250201000000_complete_database_schema.sql
CREATE OR REPLACE FUNCTION public.toggle_favorite_track(p_track_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    current_user_id UUID;
BEGIN
    -- Получение ID текущего пользователя
    current_user_id := auth.uid();
    
    -- Проверка аутентификации
    IF current_user_id IS NULL THEN
        RETURN jsonb_build_object('success', FALSE, 'error', 'User not authenticated');
    END IF;
    
    -- Безопасная операция с использованием параметризованного запроса
    -- ...
END;
$$;
```

### 4. Ограничения целостности данных

#### 4.1. Внешние ключи (Foreign Keys)

**Описание:**
- Все связи между таблицами защищены внешними ключами
- Использование CASCADE для автоматического удаления связанных записей
- Использование RESTRICT для предотвращения удаления критичных записей

**Примеры:**
```sql
-- CASCADE: при удалении пользователя удаляются его плейлисты
user_id UUID REFERENCES public.users(id) ON DELETE CASCADE

-- SET NULL: при удалении пользователя поле устанавливается в NULL
created_by UUID REFERENCES public.users(id) ON DELETE SET NULL

-- RESTRICT: нельзя удалить роль, если есть пользователи с этой ролью
role_id UUID REFERENCES public.roles(id) ON DELETE RESTRICT
```

#### 4.2. CHECK ограничения

**Описание:**
- Все таблицы содержат CHECK ограничения для валидации данных
- Проверка диапазонов значений, длин строк, допустимых значений enum

**Примеры:**
```sql
-- Проверка длины username
CHECK (LENGTH(username) >= 3 AND LENGTH(username) <= 50)

-- Проверка диапазона длительности трека
CHECK (track_duration > 0 AND track_duration <= 7200)

-- Проверка допустимых значений статуса
CHECK (status IN ('pending', 'approved', 'rejected'))
```

#### 4.3. UNIQUE ограничения

**Описание:**
- Уникальные ограничения предотвращают дублирование критичных данных
- Составные уникальные ключи для связей многие-ко-многим

**Примеры:**
```sql
-- Уникальный username
username VARCHAR(50) NOT NULL UNIQUE

-- Уникальная комбинация user_id и track_id
UNIQUE (user_id, track_id)
```

---

## ЗАЩИТА ФАЙЛОВ И STORAGE

### 5. Storage Buckets с RLS

#### 5.1. Конфигурация Storage Buckets

**Bucket: songs (Аудио файлы)**
```sql
INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
VALUES (
  'songs', 
  'songs', 
  FALSE, -- Приватный bucket
  52428800, -- 50 MB
  ARRAY['audio/mpeg', 'audio/wav', 'audio/flac', 'audio/ogg', 'audio/mp4']
);
```

**Bucket: covers (Обложки)**
```sql
INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
VALUES (
  'covers', 
  'covers', 
  TRUE, -- Публичный bucket
  5242880, -- 5 MB
  ARRAY['image/jpeg', 'image/png', 'image/webp']
);
```

**Bucket: avatars (Аватары)**
```sql
INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
VALUES (
  'avatars', 
  'avatars', 
  TRUE, -- Публичный bucket
  5242880, -- 5 MB
  ARRAY['image/jpeg', 'image/jpg', 'image/png', 'image/webp']
);
```

#### 5.2. RLS политики для Storage

**Политика: Загрузка аудио файлов (только собственные)**
```sql
CREATE POLICY "Authenticated users can upload songs"
    ON storage.objects FOR INSERT
    TO authenticated
    WITH CHECK (
        bucket_id = 'songs' 
        AND auth.uid()::text = (storage.foldername(name))[1]
    );
```

**Политика: Просмотр аудио файлов (все авторизованные пользователи)**
```sql
CREATE POLICY "Anyone can view public songs" 
    ON storage.objects FOR SELECT 
    TO authenticated 
    USING (bucket_id = 'songs');
```

**Политика: Удаление аудио файлов (только собственные)**
```sql
CREATE POLICY "Users can delete own songs"
    ON storage.objects FOR DELETE
    TO authenticated
    USING (
        bucket_id = 'songs' 
        AND auth.uid()::text = (storage.foldername(name))[1]
    );
```

**Политика: Загрузка и обновление аватаров (только собственные)**
```sql
CREATE POLICY "Authenticated users can upload avatars"
  ON storage.objects FOR INSERT
  TO authenticated
  WITH CHECK (
    bucket_id = 'avatars' 
    AND auth.uid()::text = (storage.foldername(name))[1]
  );

CREATE POLICY "Users can update own avatars"
  ON storage.objects FOR UPDATE
  TO authenticated
  USING (
    bucket_id = 'avatars' 
    AND auth.uid()::text = (storage.foldername(name))[1]
  )
  WITH CHECK (
    bucket_id = 'avatars' 
    AND auth.uid()::text = (storage.foldername(name))[1]
  );
```

#### 5.3. Валидация файлов на клиенте

**Проверка формата аудио файлов:**
```typescript:src/components/UploadTrackDialog.tsx
const audioFormats = [
  { value: "mp3", label: "MP3" },
  { value: "wav", label: "WAV" },
  { value: "flac", label: "FLAC" },
  { value: "ogg", label: "OGG" },
  { value: "m4a", label: "M4A" },
];

const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
  const file = e.target.files?.[0];
  if (file) {
    // Проверка формата файла
    const extension = file.name.split('.').pop()?.toLowerCase();
    if (!audioFormats.some(format => format.value === extension)) {
      toast.error(t('upload.error.fileFormat'));
      return;
    }

    // Проверка размера файла (50MB)
    if (file.size > 50 * 1024 * 1024) {
      toast.error(t('upload.error.fileSize'));
      return;
    }

    setFormData({ ...formData, file });
  }
};
```

**Проверка формата изображений:**
```typescript:src/components/ImageUpload.tsx
const handleFileSelect = async (e: React.ChangeEvent<HTMLInputElement>) => {
  const file = e.target.files?.[0];
  if (!file) return;

  // Проверка типа файла
  if (!file.type.startsWith('image/')) {
    toast.error(t('image.upload.selectImage'));
    return;
  }

  // Проверка размера
  const maxSizeBytes = maxSizeMB * 1024 * 1024;
  if (file.size > maxSizeBytes) {
    toast.error(t('image.upload.maxSize').replace('{size}', maxSizeMB.toString()));
    return;
  }

  // Загрузка файла
  await uploadFile(file);
};
```

---

## ЗАЩИТА НА УРОВНЕ ПРИЛОЖЕНИЯ

### 6. Защита маршрутов

#### 6.1. Компонент ProtectedRoute

**Реализация:**
```typescript:src/components/ProtectedRoute.tsx
const ProtectedRoute = ({ 
  children, 
  requiredRole,
  requireAdmin = false, 
  requireContentManagement = false 
}: ProtectedRouteProps) => {
  const { role, loading, isAdmin, canManageContent } = useRole();

  // Ожидание загрузки роли
  if (loading) {
    return <LoadingSpinner />;
  }

  // Проверка аутентификации
  if (!role) {
    return <Navigate to="/auth" replace />;
  }

  // Проверка прав администратора
  if (requireAdmin && !isAdmin) {
    return <Navigate to="/" replace />;
  }

  // Проверка прав управления контентом
  if (requireContentManagement && !canManageContent) {
    return <Navigate to="/" replace />;
  }

  // Проверка конкретной роли
  if (requiredRole && role !== requiredRole) {
    return <Navigate to="/" replace />;
  }

  return <>{children}</>;
};
```

**Использование:**
```typescript:src/App.tsx
// Защита админ-панели
<Route 
  path="/admin" 
  element={
    <ProtectedRoute requireAdmin>
      <AdminPanel />
    </ProtectedRoute>
  } 
/>

// Защита управления заявками артистов
<Route 
  path="/applications" 
  element={
    <ProtectedRoute requireContentManagement>
      <ArtistApplicationsManager />
    </ProtectedRoute>
  } 
/>
```

#### 6.2. Проверка аутентификации в Layout

**Реализация:**
```typescript:src/components/Layout.tsx
useEffect(() => {
  supabase.auth.getSession().then(({ data: { session } }) => {
    setUser(session?.user ?? null);
    if (!session?.user) {
      navigate("/auth");
    }
  });

  const {
    data: { subscription },
  } = supabase.auth.onAuthStateChange((_event, session) => {
    setUser(session?.user ?? null);
    if (!session?.user && location.pathname !== "/auth") {
      navigate("/auth");
    }
  });

  return () => subscription.unsubscribe();
}, [navigate, location.pathname]);
```

---

## СЕТЕВАЯ БЕЗОПАСНОСТЬ

### 7. HTTP заголовки безопасности

#### 7.1. Конфигурация Nginx

**Реализация:**
```nginx:nginx.conf
# Безопасность
server_tokens off;  # Скрытие версии Nginx
add_header X-Frame-Options "SAMEORIGIN" always;  # Защита от clickjacking
add_header X-XSS-Protection "1; mode=block" always;  # Защита от XSS
add_header X-Content-Type-Options "nosniff" always;  # Предотвращение MIME-sniffing
add_header Referrer-Policy "no-referrer-when-downgrade" always;  # Контроль referrer
add_header Content-Security-Policy "default-src 'self' http: https: data: blob: 'unsafe-inline'" always;  # CSP политика
```

**Описание заголовков:**

1. **X-Frame-Options: SAMEORIGIN**
   - Защита от clickjacking атак
   - Разрешает встраивание только с того же домена

2. **X-XSS-Protection: 1; mode=block**
   - Включает встроенную защиту браузера от XSS
   - Блокирует отражённые XSS атаки

3. **X-Content-Type-Options: nosniff**
   - Предотвращает MIME-sniffing
   - Заставляет браузер использовать указанный Content-Type

4. **Referrer-Policy: no-referrer-when-downgrade**
   - Контролирует передачу referrer информации
   - Не передаёт referrer при переходе с HTTPS на HTTP

5. **Content-Security-Policy**
   - Ограничивает источники загружаемых ресурсов
   - Защита от XSS и injection атак

#### 7.2. CORS политики

**Описание:**
- Supabase автоматически управляет CORS политиками
- Настройка через Supabase Dashboard
- Разрешённые источники указываются в настройках проекта

#### 7.3. Защита служебных файлов

**Реализация:**
```nginx:nginx.conf
# Безопасность - скрытие служебных файлов
location ~ /\. {
    deny all;
}
```

**Описание:**
- Блокирует доступ к скрытым файлам (начинающимся с точки)
- Защищает .env, .git и другие конфигурационные файлы

---

## ВАЛИДАЦИЯ И САНИТИЗАЦИЯ ДАННЫХ

### 8. Многоуровневая валидация

#### 8.1. Клиентская валидация

**HTML5 валидация:**
```typescript:src/pages/Auth.tsx
<Input
  id="email"
  type="email"  // HTML5 валидация формата email
  placeholder={t('auth.emailPlaceholder')}
  value={email}
  onChange={(e) => setEmail(e.target.value)}
  required  // Обязательное поле
/>

<Input
  id="password"
  type="password"
  value={password}
  onChange={(e) => setPassword(e.target.value)}
  required
  minLength={6}  // Минимальная длина пароля
/>
```

**JavaScript валидация:**
```typescript:src/pages/Auth.tsx
// Валидация username
if (!username.trim() || username.length < 3 || username.length > 50) {
  toast.error(t('auth.usernameLength'));
  setLoading(false);
  return;
}

// Проверка уникальности username
const { data: existingUser } = await supabase
  .from("users")
  .select("username")
  .eq("username", username.trim())
  .single();

if (existingUser) {
  toast.error(t('auth.usernameTaken'));
  setLoading(false);
  return;
}
```

#### 8.2. Валидация на уровне БД

**CHECK ограничения:**
- Все строковые поля имеют ограничения длины
- Все числовые поля имеют ограничения диапазона
- Все enum поля имеют ограничения допустимых значений

**Примеры:**
```sql
-- Валидация длины username
CHECK (LENGTH(username) >= 3 AND LENGTH(username) <= 50)

-- Валидация диапазона длительности трека
CHECK (track_duration > 0 AND track_duration <= 7200)

-- Валидация статуса анкеты
CHECK (status IN ('pending', 'approved', 'rejected'))
```

#### 8.3. Санитизация данных

**Метод:** Автоматическая санитизация через Supabase

**Описание:**
- Supabase автоматически экранирует специальные символы
- Типы данных автоматически приводятся к ожидаемым форматам
- SQL инъекции невозможны через параметризованные запросы

**Пример:**
```typescript
// Автоматическая санитизация через Supabase
const { error } = await supabase
  .from("users")
  .update({
    username: username.trim(),  // Удаление пробелов
    first_name: firstName.trim() || null,  // Обработка NULL
    last_name: lastName.trim() || null,
  })
  .eq("id", user.id);
```

---

## АУДИТ И МОНИТОРИНГ

### 9. Система аудита

#### 9.1. Таблица audit_log

**Структура:**
```sql
CREATE TABLE public.audit_log (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES public.users(id) ON DELETE SET NULL,
    action_type VARCHAR(100) NOT NULL,
    table_name VARCHAR(50) NOT NULL,
    record_id UUID,
    old_value JSONB,
    new_value JSONB,
    timestamp TIMESTAMPTZ NOT NULL DEFAULT now(),
    CHECK (action_type IN ('INSERT', 'UPDATE', 'DELETE', 'SELECT', 'LOGIN', 'LOGOUT')),
    CHECK (table_name IN ('users', 'artists', 'albums', 'tracks', 'playlists', ...))
);
```

#### 9.2. Триггеры аудита

**Функция аудита:**
```sql:supabase/migrations/20250201000000_complete_database_schema.sql
CREATE OR REPLACE FUNCTION public.audit_changes()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    INSERT INTO public.audit_log (user_id, action_type, table_name, record_id, new_value)
    VALUES (auth.uid(), 'INSERT', TG_TABLE_NAME, NEW.id, row_to_json(NEW)::jsonb);
    RETURN NEW;
  ELSIF TG_OP = 'UPDATE' THEN
    INSERT INTO public.audit_log (user_id, action_type, table_name, record_id, old_value, new_value)
    VALUES (auth.uid(), 'UPDATE', TG_TABLE_NAME, NEW.id, row_to_json(OLD)::jsonb, row_to_json(NEW)::jsonb);
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    INSERT INTO public.audit_log (user_id, action_type, table_name, record_id, old_value)
    VALUES (auth.uid(), 'DELETE', TG_TABLE_NAME, OLD.id, row_to_json(OLD)::jsonb);
    RETURN OLD;
  END IF;
END;
$$;
```

**Триггеры:**
```sql
-- Аудит изменений треков
CREATE TRIGGER audit_tracks_trigger
  AFTER INSERT OR UPDATE OR DELETE ON public.tracks
  FOR EACH ROW
  EXECUTE FUNCTION public.audit_changes();

-- Аудит изменений плейлистов
CREATE TRIGGER audit_playlists_trigger
  AFTER INSERT OR UPDATE OR DELETE ON public.playlists
  FOR EACH ROW
  EXECUTE FUNCTION public.audit_changes();
```

#### 9.3. RLS политики для audit_log

**Политика: Просмотр собственных логов**
```sql
CREATE POLICY "Users can view own audit logs" ON public.audit_log FOR
SELECT TO authenticated USING (user_id = auth.uid());
```

**Описание:**
- Пользователи могут видеть только свои записи аудита
- Администраторы могут видеть все записи (через отдельную политику)

---

## ЗАЩИТА ОТ УЯЗВИМОСТЕЙ

### 10. Защита от основных атак

#### 10.1. SQL Injection

**Методы защиты:**
- ✅ Параметризованные запросы через Supabase Client API
- ✅ Отсутствие прямых SQL запросов в клиентском коде
- ✅ Использование функций с проверкой параметров

**Пример защищённого запроса:**
```typescript
// ✅ Безопасно: параметризованный запрос
const { data } = await supabase
  .from("tracks")
  .select("*")
  .eq("id", trackId);

// ❌ НЕ используется: прямой SQL запрос
// const { data } = await supabase.rpc('execute_sql', { sql: `SELECT * FROM tracks WHERE id = '${trackId}'` });
```

#### 10.2. XSS (Cross-Site Scripting)

**Методы защиты:**
- ✅ React автоматически экранирует данные в JSX
- ✅ HTTP заголовок X-XSS-Protection
- ✅ Content-Security-Policy
- ✅ Валидация и санитизация всех пользовательских данных

**Пример:**
```typescript
// React автоматически экранирует user input
<div>{username}</div>  // Безопасно: HTML теги экранируются

// Для HTML контента используется dangerouslySetInnerHTML с санитизацией
// (не используется в проекте, но если понадобится - через DOMPurify)
```

#### 10.3. CSRF (Cross-Site Request Forgery)

**Методы защиты:**
- ✅ SameSite cookies (настроено в Supabase)
- ✅ Проверка origin в запросах
- ✅ JWT токены с ограниченным временем жизни

**Описание:**
- Supabase автоматически защищает от CSRF через JWT токены
- Токены привязаны к домену и имеют ограниченный срок жизни
- Запросы без valid токена отклоняются

#### 10.4. Brute Force

**Методы защиты:**
- ✅ Ограничение попыток входа через Supabase
- ✅ Rate limiting на уровне Supabase
- ✅ Валидация сложности пароля (минимум 6 символов)

**Описание:**
- Supabase автоматически ограничивает количество попыток входа
- После нескольких неудачных попыток аккаунт временно блокируется
- Требуется минимальная длина пароля

#### 10.5. Несанкционированный доступ к данным

**Методы защиты:**
- ✅ Row Level Security (RLS) на всех таблицах
- ✅ Проверка прав доступа на уровне БД
- ✅ Защита маршрутов на клиенте
- ✅ Проверка ролей перед выполнением операций

**Пример:**
```sql
-- Пользователь может видеть только свои плейлисты
CREATE POLICY "Users can view own playlists" ON public.playlists FOR
SELECT TO authenticated USING (user_id = auth.uid());
```

---

## ДОПОЛНИТЕЛЬНЫЕ МЕРЫ ЗАЩИТЫ

### 11. Безопасность окружения

#### 11.1. Переменные окружения

**Файл:** `env.example`
```env
# Переменные окружения для ImperialTunes
# Скопируйте этот файл в .env.local и заполните значения

# Supabase Configuration
VITE_SUPABASE_URL=your_supabase_project_url
VITE_SUPABASE_ANON_KEY=your_supabase_anon_key
```

**Описание:**
- Критичные данные (API ключи) хранятся в переменных окружения
- Файл `.env.local` добавлен в `.gitignore`
- Публичный ключ (ANON_KEY) безопасен для использования на клиенте

#### 11.2. Docker безопасность

**Реализация:**
```dockerfile:Dockerfile
# Создаем непривилегированного пользователя
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nextjs -u 1001

# Устанавливаем права доступа
RUN chown -R nextjs:nodejs /usr/share/nginx/html
RUN chown -R nextjs:nodejs /var/cache/nginx

# Переключаемся на непривилегированного пользователя
USER nextjs
```

**Описание:**
- Приложение запускается от непривилегированного пользователя
- Ограничение прав доступа к файловой системе
- Изоляция контейнеров через Docker network

---

## ИТОГОВАЯ ТАБЛИЦА МЕР ЗАЩИТЫ

### Таблица 1: Меры защиты данных

| № | Категория защиты | Метод реализации | Уровень защиты | Файл/Компонент |
|---|------------------|-------------------|----------------|----------------|
| 1 | Хэширование паролей | Supabase Auth (bcrypt) | Критический | `auth.users` (Supabase) |
| 2 | Управление сессиями | JWT токены | Критический | Supabase Auth |
| 3 | Контроль доступа к БД | Row Level Security (RLS) | Критический | Все таблицы БД |
| 4 | Защита от SQL инъекций | Параметризованные запросы | Высокий | Supabase Client API |
| 5 | Ролевая модель | RBAC через таблицу roles | Высокий | `public.roles`, `public.users` |
| 6 | Валидация данных | CHECK ограничения БД | Высокий | Все таблицы БД |
| 7 | Защита файлов | Storage RLS политики | Высокий | Storage buckets |
| 8 | Защита маршрутов | ProtectedRoute компонент | Средний | `src/components/ProtectedRoute.tsx` |
| 9 | HTTP заголовки | Security headers в Nginx | Средний | `nginx.conf` |
| 10 | Защита от XSS | React экранирование + CSP | Средний | React, Nginx |
| 11 | Защита от CSRF | SameSite cookies + JWT | Средний | Supabase Auth |
| 12 | Аудит операций | Таблица audit_log + триггеры | Средний | `public.audit_log` |
| 13 | Валидация файлов | Клиентская + серверная проверка | Средний | `UploadTrackDialog.tsx`, `ImageUpload.tsx` |
| 14 | Ограничение размера файлов | Storage bucket limits | Средний | Storage buckets |
| 15 | Валидация форматов файлов | MIME-type проверка | Средний | Storage buckets, клиент |

---

## ЗАКЛЮЧЕНИЕ

Проект Imperial Tunes реализует комплексную систему защиты данных на всех уровнях:

1. **Аутентификация** - безопасное хранение паролей через bcrypt, управление сессиями через JWT
2. **Авторизация** - контроль доступа через RLS политики и ролевую модель
3. **Защита БД** - параметризованные запросы, CHECK ограничения, внешние ключи
4. **Защита файлов** - RLS политики для Storage, валидация форматов и размеров
5. **Защита приложения** - защита маршрутов, валидация данных, HTTP заголовки
6. **Аудит** - полное логирование всех операций через audit_log

Все меры защиты соответствуют современным стандартам безопасности и обеспечивают защиту данных пользователей на всех этапах работы приложения.

---